!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("gpu.js")):"function"==typeof define&&define.amd?define(["exports","gpu.js"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).brain={},t.gpu_js)}(this,function(t,e){"use strict";function i(t){return Math.max(0,t)}function r(t,e){return t<=0?0:e}var n=Object.freeze({__proto__:null,activate:i,measure:r});function s(t){return 1/(1+Math.exp(-t))}function o(t,e){return t*(1-t)*e}var h=Object.freeze({__proto__:null,activate:s,measure:o});function a(t){return Math.tanh(t)}function u(t,e){return(1-t*t)*e}var l=Object.freeze({__proto__:null,activate:a,measure:u});function p(t){return t>0?t:.01*t}function c(t,e){return t>0?e:.01*e}var d=Object.freeze({__proto__:null,activate:p,measure:c}),g=Object.freeze({__proto__:null,relu:n,sigmoid:h,tanh:l,leakyRelu:d});class f{constructor(t){this.json={avgs:{error:0,iterations:0,testTime:0,trainTime:0},stats:{total:0,testSize:0,trainSize:0},sets:[]},this.initClassifier=t}testPartition(t,e,i){const r=this.initClassifier(),n=Date.now(),s=r.train(e,t),o=Date.now(),h=r.test(i),a=Date.now();return{...h,trainTime:o-n,testTime:a-o,iterations:s.iterations,error:s.error,total:h.total,network:r.toJSON()}}shuffleArray(t){for(let e=t.length-1;e>0;e--){const i=Math.floor(Math.random()*(e+1)),r=t[e];t[e]=t[i],t[i]=r}return t}train(t,e={},i=4){if(t.length<i)throw new Error(`Training set size is too small for ${t.length} k folds of ${i}`);this.shuffleArray(t);const r=t.length/i,n={trainTime:0,testTime:0,iterations:0,error:0},s={total:0,testSize:0,trainSize:0},o={total:0,testSize:0,trainSize:0,truePos:0,trueNeg:0,falsePos:0,falseNeg:0,precision:0,recall:0,accuracy:0},h=[];let a=null;for(let u=0;u<i;u++){const i=t.slice(0),l=i.splice(u*r,r),p=i,c=this.testPartition(e,p,l);null===a&&(a=c.hasOwnProperty("falseNeg")&&c.hasOwnProperty("falsePos")&&c.hasOwnProperty("trueNeg")&&c.hasOwnProperty("truePos"))&&Object.assign(s,o),n.iterations+=c.iterations,n.testTime+=c.testTime,n.trainTime+=c.trainTime,n.error+=c.error,s.total+=c.total,f.isBinaryStats(s)&&f.isBinaryPartitionResults(c)&&(s.accuracy+=c.accuracy,s.falseNeg+=c.falseNeg,s.falsePos+=c.falsePos,s.precision+=c.precision,s.recall+=c.recall,s.trueNeg+=c.trueNeg,s.truePos+=c.truePos),h.push(c)}return n.error/=i,n.iterations/=i,n.testTime/=i,n.trainTime/=i,f.isBinaryStats(s)&&(s.precision=s.truePos/(s.truePos+s.falsePos),s.recall=s.truePos/(s.truePos+s.falseNeg),s.accuracy=(s.trueNeg+s.truePos)/s.total),s.testSize=r,s.trainSize=t.length-r,this.json={avgs:n,stats:s,sets:h},this.json}toNeuralNetwork(){return this.fromJSON(this.json)}toJSON(){return this.json}fromJSON(t){const e=t.sets.reduce((t,e)=>t.error<e.error?t:e);return this.initClassifier().fromJSON(e.network)}}f.isBinaryStats=(t=>void 0!==t.accuracy),f.isBinaryResults=(t=>void 0!==t.stats.accuracy),f.isBinaryPartitionResults=(t=>void 0!==t.accuracy);let w=null;function y(t){w=t}function m(t,i){let r=w;return null===r&&y(r=new e.GPU({mode:"gpu"})),r.createKernel(t,i).setPipeline(!0)}function L(t,i,r){let n=w;return null===n&&y(n=new e.GPU({mode:"gpu"})),n.createKernelMap(t,i,r).setPipeline(!0)}function b(t){t instanceof e.Texture&&t.delete()}function x(t){if(t instanceof e.Texture)return t.clone();if(t instanceof Float32Array)return t.slice(0);if(Array.isArray(t)){if("number"==typeof t[0])return t.slice(0);if("number"==typeof t[0][0]){const e=new Array(t.length);for(let i=0;i<t.length;i++)e[i]=t[i].slice(0);return e}if("number"==typeof t[0][0][0]){const e=new Array(t.length);for(let e=0;e<t.length;e++){const i=t[e],r=new Array(i.length);for(let t=0;t<i.length;t++)r[t]=i[t].slice(0)}return e}}throw new Error("unhandled value")}function k(t){let e=0;for(let i=0;i<this.constants.height;i++)for(let r=0;r<this.constants.width;r++)e+=t[i][r]**2;return e/this.constants.length}class O{constructor({width:t,height:e}){this.calculate=m(k,{output:[1],constants:{width:t,height:e,length:t*e},immutable:!0}),this.addAbsolute=m(function(t,e){return t[0]+Math.abs(e[0][0])},{output:[1],immutable:!0}),this.add=m(function(t,e){return t[0]+e[0]},{output:[1],immutable:!0}),this.divide=m(function(t,e){const i=e[0];return i>0?i/t:0},{output:[1],immutable:!0})}}const v={width:1,height:1,depth:null,weights:null,deltas:null,praxis:null,praxisOpts:null,cleanupDeltas:!0};class A{constructor(t){this.praxis=null,this.predictKernel=null,this.compareKernel=null,this.settings=t?{...v,...t}:{...v},this.setupPraxis()}get width(){var t;return null!==(t=this.settings.width)&&void 0!==t?t:0}get height(){var t;return null!==(t=this.settings.height)&&void 0!==t?t:0}get depth(){var t;return null!==(t=this.settings.depth)&&void 0!==t?t:0}get weights(){return this.settings.weights}set weights(t){this.settings.weights=t,this.settings.cleanupDeltas&&this.deltas&&function(t){if(t instanceof e.Texture)t.clear();else{if(Array.isArray(t))if("number"==typeof t[0])t.fill(0);else{if("number"==typeof t[0][0]){for(let e=0;e<t.length;e++)t[e].fill(0);return}if("number"==typeof t[0][0][0]){for(let e=0;e<t.length;e++){const i=t[e];for(let t=0;t<i.length;t++)i[t].fill(0)}return}}if(!(t instanceof Float32Array))throw new Error("unhandled value");t.fill(0)}}(this.deltas)}get deltas(){return this.settings.deltas}set deltas(t){this.settings.deltas=t}get id(){var t;return null!==(t=this.settings.id)&&void 0!==t?t:""}set id(t){this.settings.id=t}setupPraxis(){const{initPraxis:t,praxis:e,praxisOpts:i}=this.settings;this.praxis||(t?this.praxis=i?t(this,i):t(this):e&&(this.praxis=e))}validate(){if(Number.isNaN(this.height))throw new Error(`${this.constructor.name} layer height is not a number`);if(Number.isNaN(this.width))throw new Error(`${this.constructor.name} layer width is not a number`);if(this.height<1)throw new Error(`${this.constructor.name} layer height is less than 1`);if(this.width<1)throw new Error(`${this.constructor.name} layer width is less than 1`)}setupKernels(t){}reuseKernels(t){if(t.width!==this.width)throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);if(t.height!==this.height)throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);if(t.hasOwnProperty("predictKernel")&&null!==t.predictKernel){if(!t.predictKernel.immutable)throw new Error(`${t.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);this.predictKernel=t.predictKernel}if(t.hasOwnProperty("compareKernel")&&null!==t.compareKernel){if(!t.compareKernel.immutable)throw new Error(`${t.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);this.compareKernel=t.compareKernel}this.praxis=t.praxis}predict(t){}compare(t){}learn(t){}toArray(){return Array.isArray(this.weights)?this.weights:this.weights.toArray()}toJSON(){return A.toJSON(this)}static toJSON(t){const{weights:i}=t;return{width:t.width,height:t.height,depth:t.depth,weights:S(i&&i instanceof e.Texture?i.toArray():i),type:t.constructor.name,praxisOpts:t.praxis?t.praxis.toJSON():null}}}function S(t){if(null===t)return null;if(Array.isArray(t)){if("number"==typeof t[0])return t;if(Array.isArray(t[0])&&"number"==typeof t[0][0])return t;if(Array.isArray(t[0][0])&&"number"==typeof t[0][0][0])return t;if(t[0]instanceof Float32Array){return t.map(t=>Array.from(t))}if(t[0][0]instanceof Float32Array){return t.map(t=>t.map(t=>Array.from(t)))}}else if(t)return Array.from(t);throw new Error("unexpected value")}function I(t){return new Float32Array(t)}function z(t,e){const i=new Array(e);for(let r=0;r<e;r++)i[r]=I(t);return i}function E(t,e,i){const r=new Array(i);for(let n=0;n<i;n++)r[n]=z(t,e);return r}class $ extends A{constructor(t,e){super(e),this.inputLayer=t;const{width:i,height:r,depth:n}=this;this.predictKernel=null,this.compareKernel=null,this.validate(),n>0?(this.weights=E(i,r,n),this.deltas=E(i,r,n)):r>0&&(this.weights=z(i,r),this.deltas=z(i,r)),this.setupPraxis()}get width(){return this.inputLayer.width}get height(){return this.inputLayer.height}get depth(){return this.inputLayer.depth}}class M extends A{constructor(t,e){super(),this.settings=t,this.inputLayer=e}get width(){return this.inputLayer.width}get height(){return this.inputLayer.height}get depth(){return this.inputLayer.depth}get filterCount(){return this.settings.filterCount}get filterWidth(){return this.settings.filterWidth}get filterHeight(){return this.settings.filterHeight}get filters(){return this.settings.filters}set filters(t){this.settings.filters=t}get filterDeltas(){return this.settings.filterDeltas}set filterDeltas(t){this.settings.filterDeltas=t}}class P{constructor(){this.predictKernel=null,this.compareKernel=null,this.praxis=null}get width(){return this.settings.width}get height(){return this.settings.height}get depth(){return this.settings.depth}get weights(){return this.settings.weights}set weights(t){this.settings.weights=t}get deltas(){return this.settings.deltas}set deltas(t){this.settings.deltas=t}toJSON(){return A.toJSON(this)}}class _ extends A{constructor(t,e){super({...e,width:t.width,height:t.height,depth:t.depth}),this.inputLayer=t}validate(){var t;if(super.validate(),this.width!==this.inputLayer.width)throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);if(this.height!==this.inputLayer.height)throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);if(this.depth!==(null!==(t=this.inputLayer.depth)&&void 0!==t?t:0))throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`)}}class K extends A{constructor(t,e,i){super(i),this.inputLayer1=t,this.inputLayer2=e,this.validate(),this.weights=z(this.width,this.height),this.deltas=z(this.width,this.height),this.setupPraxis()}}function T(t,e){return t[this.thread.y][this.thread.x]-e[this.thread.x]}function D(t,e){return t[this.thread.y][this.thread.x]-e[this.thread.y][this.thread.x]}class j extends A{constructor(t,e){if(super(t),this.inputLayer=e,this.validate(),this.depth)throw new Error("Target layer not implemented for depth");this.height?(this.weights=z(this.width,this.height),this.deltas=z(this.width,this.height),this.errors=z(this.width,this.height)):(this.weights=I(this.width),this.deltas=I(this.width),this.errors=I(this.width))}setupKernels(){1===this.width?this.compareKernel=m(T,{output:[this.width,this.height],immutable:!0}):this.compareKernel=m(D,{output:[this.width,this.height],immutable:!0})}predict(){b(this.weights),this.weights=x(this.inputLayer.weights)}compare(t){b(this.deltas),b(this.errors),b(this.inputLayer.deltas),this.deltas=this.compareKernel(this.weights,t),this.inputLayer.deltas=x(this.deltas),this.errors=x(this.deltas)}setupPraxis(){}}function F(t,e){return new j(t,e)}class N{}class C extends A{}class R extends A{learn(t){const{weights:e}=this;if(!this.praxis)throw new Error("this.praxis not defined");this.weights=this.praxis.run(this,t),b(e)}}const H={toTable(t){const e=t.reduce((t,e)=>Object.assign(t,e),{});return H.toHash(e)},toTable2D(t){const e={};let i=0;for(let r=0;r<t.length;r++){const n=t[r];for(let t=0;t<n.length;t++){const r=n[t];for(const t in r)r.hasOwnProperty(t)&&!e.hasOwnProperty(t)&&(e[t]=i++)}}return e},toInputTable2D(t){const e={};let i=0;for(let r=0;r<t.length;r++){const n=t[r].input;for(let t=0;t<n.length;t++){const r=n[t];for(const t in r)r.hasOwnProperty(t)&&(e.hasOwnProperty(t)||(e[t]=i++))}}return e},toOutputTable2D(t){const e={};let i=0;for(let r=0;r<t.length;r++){const n=t[r].output;for(let t=0;t<n.length;t++){const r=n[t];for(const t in r)r.hasOwnProperty(t)&&(e.hasOwnProperty(t)||(e[t]=i++))}}return e},toHash(t){const e={};let i=0;const r=Object.keys(t);for(let t=0;t<r.length;t++)e[r[t]]=i++;return e},toArray(t,e,i){const r=new Float32Array(i);for(const i in t)t.hasOwnProperty(i)&&(r[t[i]]=e.hasOwnProperty(i)?e[i]:0);return r},toArrayShort(t,e){const i=[];for(const r in t)if(t.hasOwnProperty(r)){if(!e.hasOwnProperty(r))break;i[t[r]]=e[r]}return Float32Array.from(i)},toArrays(t,e,i){const r=[];for(let n=0;n<e.length;n++)r.push(this.toArray(t,e[n],i));return r},toObject(t,e){const i={};for(const r in t)t.hasOwnProperty(r)&&(i[r]=e[t[r]]);return i},toObjectPartial(t,e,i=0,r=0){const n={};let s=0;for(const o in t)t.hasOwnProperty(o)&&(i>0&&s++<i||r>0&&s++>=r||(n[o]=e[t[o]-i]));return n},dataShape(t){const e=[];let i,r;for(t.hasOwnProperty("input")?(e.push("datum"),i=t.input):Array.isArray(t)?t[0]&&t[0].input?(e.push("array","datum"),i=t[0].input):Array.isArray(t[0])?(e.push("array"),i=t[0]):i=t:i=t;i;)if(r=Object.keys(i)[0],Array.isArray(i)||"object"==typeof i.buffer){e.push("array");const t=i[parseInt(r)];if("number"==typeof t){e.push("number");break}i=t}else{if("object"!=typeof i||"object"==typeof i.buffer)throw new Error("unhandled signature");{e.push("object");const t=i[r];if("number"==typeof t){e.push("number");break}i=t}}return e},addKeys(t,e){if(Array.isArray(t))return e;let i=Object.keys(e).length;for(const r in t)t.hasOwnProperty(r)&&(e.hasOwnProperty(r)||(e[r]=i++));return e}};class q{constructor(t,e={}){this.layerTemplate=t,this.settings={...e},this.kernel=null}get width(){return this.layerTemplate.width}get height(){return this.layerTemplate.height}get depth(){return this.layerTemplate.depth}setupKernels(){}reuseKernels(t){if(t.width!==this.width)throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);if(t.height!==this.height)throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);t.hasOwnProperty("kernel")&&(this.kernel=t.kernel)}toJSON(){return{...this.settings}}}function W(t,e){return t[this.thread.y][this.thread.x]+this.constants.learningRate*e[this.thread.y][this.thread.x]}const X={learningRate:.3};class Y extends q{constructor(t,e){super(t),this.settings={...X,...e},this.kernel=null}run(t){return this.kernel(t.weights,t.deltas)}setupKernels(){this.kernel=m(W,{output:[this.width,this.height],constants:{learningRate:this.settings.learningRate}})}}function J(t,e){return new Y(t,e)}function B(t){return t}function G(t,e,i,r){const n=t[this.thread.y][this.thread.x],s=r[this.thread.y][0],o=e[this.thread.y][this.thread.x],h=i[this.thread.x][0];return o+(this.constants.learningRate*s*h+this.constants.momentum*n)}const V={learningRate:.3,momentum:.1,weightsLayer:null,incomingLayer:null,deltaLayer:null};class U extends q{constructor(t,e){super(t),this.kernelMap=null,this.settings={...V,...e},this.changes=z(t.width,t.height)}get learningRate(){return this.settings.learningRate}get momentum(){return this.settings.momentum}get weightsLayer(){return this.settings.weightsLayer}set weightsLayer(t){this.settings.weightsLayer=t}get deltaLayer(){return this.settings.deltaLayer}set deltaLayer(t){this.settings.deltaLayer=t}get incomingLayer(){return this.settings.incomingLayer}set incomingLayer(t){this.settings.incomingLayer=t}run(){const t=this.kernelMap(this.changes,this.weightsLayer.weights,this.incomingLayer.weights,this.deltaLayer.deltas);return this.changes=t.changes,t.result}setupKernels(){this.kernelMap=L({changes:B},G,{output:[this.width,this.height],constants:{learningRate:this.learningRate,momentum:this.momentum}})}}function Z(t,e){return new U(t,e)}function Q(t,e,i){return i*e+(1-e)*t*t}function tt(t,e,i){return t>e?e:t<i?i:t}function et(t,e,i){const r=e[this.thread.y][this.thread.x],n=tt(r,this.constants.clipValue,-this.constants.clipValue),s=t[this.thread.y][this.thread.x],o=i[this.thread.y][this.thread.x],h=Q(r,this.constants.decayRate,o);return s+-this.constants.learningRate*n/Math.sqrt(h+this.constants.smoothEps)-this.constants.regularizationStrength*s}const it={decayRate:.999,regularizationStrength:1e-6,learningRate:.01,smoothEps:1e-8,clipValue:5};class rt extends q{constructor(t,e={}){super(t),this.kernelMap=null,this.settings={...it,...e},this.momenta=z(t.width,t.height)}get clipValue(){return this.settings.clipValue}get decayRate(){return this.settings.decayRate}get learningRate(){return this.settings.learningRate}get regularizationStrength(){return this.settings.regularizationStrength}get smoothEps(){return this.settings.smoothEps}run(t){const{momenta:e,result:i}=this.kernelMap(t.weights,t.deltas,this.momenta);return b(this.momenta),this.momenta=e,i}setupKernels(){this.kernelMap=L({momenta:Q},et,{output:[this.width,this.height],constants:{clipValue:this.clipValue,decayRate:this.decayRate,learningRate:this.learningRate,regularizationStrength:this.regularizationStrength,smoothEps:this.smoothEps},functions:[tt],immutable:!0})}}function nt(t,e){return new rt(t,e)}const st=rt,ot=nt;var ht=Object.freeze({__proto__:null,ArthurDeviationBiases:Y,arthurDeviationBiases:J,ArthurDeviationWeights:U,arthurDeviationWeights:Z,MomentumRootMeanSquaredPropagation:rt,momentumRootMeanSquaredPropagation:nt,MRmsProp:st,mRmsProp:ot});function at(t,e){t.hasOwnProperty("inputLayer")?at(t.inputLayer,e):(t.hasOwnProperty("inputLayer1")&&at(t.inputLayer1,e),t.hasOwnProperty("inputLayer2")&&at(t.inputLayer2,e)),e(t)}function ut(t){const e=t.slice(0);for(let t=0;t<e.length;t++){let i=0;at(e[t],r=>{e.includes(r)||(e.splice(t+i,0,r),i++)})}return e}function lt(t,e){if(t.width!==e.width)throw new Error(`Layer width mismatch of ${t.width} and ${e.width}`);if(t.height!==e.height)throw new Error(`Layer height mismatch of ${t.height} and ${e.height}`)}function pt(t,e){return t[this.thread.y][this.thread.x]+e[this.thread.y][this.thread.x]}class ct extends K{get width(){return this.inputLayer1.width}get height(){return this.inputLayer1.height}get depth(){return this.inputLayer1.depth}validate(){super.validate(),lt(this.inputLayer1,this.inputLayer2)}setupKernels(){this.predictKernel=m(pt,{output:[this.width,this.height],immutable:!0})}predict(){b(this.weights),this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){b(this.inputLayer1.deltas),b(this.inputLayer2.deltas),this.inputLayer1.deltas=x(this.deltas),this.inputLayer2.deltas=x(this.deltas)}}function dt(t,e,i){return new ct(t,e,i)}function gt(){return.4*Math.random()-.2}function ft(t,e){return Math.random()*(e-t)+t}function wt(){if(wt.returnV)return wt.returnV=!1,wt.vVal;const t=2*Math.random()-1,e=2*Math.random()-1,i=t*t+e*e;if(0===i||i>1)return wt();const r=Math.sqrt(-2*Math.log(i)/i);return wt.vVal=e*r,wt.returnV=!0,t*r}wt.returnV=!1,wt.vVal=0;var yt=Object.freeze({__proto__:null,randomFloat:ft,gaussRandom:wt,randomInteger:function(t,e){return Math.floor(Math.random()*(e-t)+t)},randomN:function(t,e){return t+wt()*e}});function mt(t,e=null){const i=new Float32Array(t);if(null===e)for(let e=0;e<t;e++)i[e]=gt();else for(let r=0;r<t;r++)i[r]=ft(-e,e);return i}function Lt(t,e,i){const r=new Array(e);for(let n=0;n<e;n++)r[n]=mt(t,i);return r}function bt(t,e,i,r){const n=new Array(i);for(let s=0;s<i;s++)n[s]=Lt(t,e,r);return n}const xt={...v,std:null};class kt extends R{constructor(t){super(),this.settings={...xt,...t},this.setupPraxis(),this.validate(),this.weights||(this.weights=Lt(this.width,this.height,t.std)),this.deltas||(this.deltas=z(this.width,this.height))}predict(){}compare(){}}function Ot(t){return new kt(t)}function vt(t,e){let i=0;for(let r=0;r<this.constants.size;r++)i+=t[this.thread.y][r]*e[r][this.thread.x];return i}function At(t,e,i){let r=e[this.thread.y][this.thread.x];for(let e=0;e<this.constants.size;e++)r+=t[this.thread.y][e]*i[this.thread.x][e];return r}function St(t,e,i){let r=e[this.thread.y][this.thread.x];for(let e=0;e<this.constants.size;e++)r+=t[e][this.thread.x]*i[e][this.thread.y];return r}class It extends K{constructor(){super(...arguments),this.compareKernel1=null,this.compareKernel2=null}get width(){return this.inputLayer2.width}set width(t){throw new Error("Cannot set width on Multiply")}get height(){return this.inputLayer1.height}set height(t){throw new Error("Cannot set height on Multiply")}get depth(){return this.inputLayer1.depth}set depth(t){throw new Error("Cannot set depth on Multiply")}validate(){if(super.validate(),this.inputLayer1.width!==this.inputLayer2.height)throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`)}setupKernels(){this.predictKernel=m(vt,{output:[this.width,this.height],constants:{size:this.inputLayer2.height},immutable:!0}),this.compareKernel1=m(At,{output:[this.inputLayer1.width,this.inputLayer1.height],constants:{size:this.inputLayer2.width},immutable:!0}),this.compareKernel2=m(St,{output:[this.inputLayer2.width,this.inputLayer2.height],constants:{size:this.inputLayer1.height},immutable:!0})}reuseKernels(t){super.reuseKernels(t),this.compareKernel1=t.compareKernel1,this.compareKernel2=t.compareKernel2}predict(){if(b(this.weights),!this.predictKernel)throw new Error("this.predictKernel is not set");this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){if(!this.compareKernel1)throw new Error("this.compareKernel1 not set");if(!this.compareKernel2)throw new Error("this.compareKernel2 not set");const t=this.inputLayer1.deltas,e=this.inputLayer2.deltas,i=this.compareKernel1(this.deltas,this.inputLayer1.deltas,this.inputLayer2.weights),r=this.compareKernel2(this.deltas,this.inputLayer2.deltas,this.inputLayer1.weights);this.inputLayer2.deltas=r,this.inputLayer1.deltas=i,b(t),b(e)}setupPraxis(){}toJSON(){return{...super.toJSON(),width:this.width,height:this.height}}}function zt(t,e,i){return new It(t,e,i)}function Et(t){return 1/(1+Math.exp(-t[this.thread.y][this.thread.x]))}function $t(t){return 1/(1+Math.exp(-t[this.thread.z][this.thread.y][this.thread.x]))}function Mt(t,e){const i=t[this.thread.y][this.thread.x];return i*(1-i)*e[this.thread.y][this.thread.x]}function Pt(t,e){const i=t[this.thread.z][this.thread.y][this.thread.x];return i*(1-i)*e[this.thread.z][this.thread.y][this.thread.x]}class _t extends ${setupKernels(){this.depth>0?(this.predictKernel=m($t,{output:[this.width,this.height,this.depth],functions:[s],immutable:!0}),this.compareKernel=m(Pt,{output:[this.width,this.height,this.depth],functions:[o],immutable:!0})):(this.predictKernel=m(Et,{output:[this.width,this.height],functions:[s],immutable:!0}),this.compareKernel=m(Mt,{output:[this.width,this.height],functions:[o],immutable:!0}))}predict(){b(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){b(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}learn(t){}}function Kt(t,e){return new _t(t,e)}function Tt(t,e){if("number"==typeof t.stride)return{strideX:t.stride,strideY:t.stride};{let i=e.stride,r=e.stride;return"number"==typeof t.strideX&&(i=t.strideX),"number"==typeof t.strideY&&(r=t.strideY),{strideX:i,strideY:r}}}function Dt(t,e){if("number"==typeof t.padding)return{paddingX:t.padding,paddingY:t.padding};{let i=e.padding,r=e.padding;return"number"==typeof t.paddingX&&(i=t.paddingX),"number"==typeof t.paddingY&&(r=t.paddingY),{paddingX:i,paddingY:r}}}function jt(t,e){return new Float32Array(t).fill(e)}function Ft(t,e,i){const r=this.constants.paddingX-this.thread.x*this.constants.strideX,n=this.thread.x*this.constants.strideX-this.constants.paddingX,s=Math.min(this.constants.filterWidth,r+this.constants.inputWidth),o=this.constants.paddingY-this.thread.y*this.constants.strideY,h=this.thread.y*this.constants.strideY-this.constants.paddingY,a=Math.min(this.constants.filterHeight,o+this.constants.inputHeight);let u=0;for(let i=0;i<this.constants.inputDepth;i++)for(let l=Math.max(0,o),p=Math.max(0,h);l<a;l++,p++)for(let o=Math.max(0,r),h=Math.max(0,n);o<s;o++,h++)u+=e[i][l][o]*t[i][p][h];return u+i[this.thread.z]}function Nt(t,e,i){const r=Math.max(0,Math.ceil((this.constants.paddingX-this.thread.x)/this.constants.strideX)),n=r*this.constants.strideX+this.thread.x-this.constants.paddingX,s=Math.min(this.constants.deltaWidth,Math.floor((this.constants.inputWidth-1-this.thread.x+this.constants.paddingX)/this.constants.strideX)+1),o=Math.max(0,Math.ceil((this.constants.paddingY-this.thread.y)/this.constants.strideY)),h=o*this.constants.strideY+this.thread.y-this.constants.paddingY,a=Math.min(this.constants.deltaHeight,Math.floor((this.constants.inputHeight-1-this.thread.y+this.constants.paddingY)/this.constants.strideY)+1);let u=t[this.thread.z][this.thread.y][this.thread.x];for(let t=o,l=h;t<a;t++,l+=this.constants.strideY)for(let o=r,h=n;o<s;o++,h+=this.constants.strideX)u+=e[this.thread.z][l][h]*i[this.constants.deltaZ][t][o];return u}function Ct(t,e,i){const r=this.thread.x+this.constants.paddingX,n=r<this.constants.filterWidth?0:Math.floor((r-this.constants.filterWidth+this.constants.strideX)/this.constants.strideX),s=r-n*this.constants.strideX,o=Math.min(n+Math.floor(s/this.constants.strideX)+1,this.constants.deltaWidth),h=this.thread.y+this.constants.paddingY,a=h<this.constants.filterHeight?0:Math.floor((h-this.constants.filterHeight+this.constants.strideY)/this.constants.strideY),u=h-a*this.constants.strideY,l=Math.min(a+Math.floor(u/this.constants.strideY)+1,this.constants.deltaHeight);let p=t[this.thread.z][this.thread.y][this.thread.x],c=a;for(let t=u;c<l;t-=this.constants.strideY,c++){let r=n;for(let n=s;r<o;n-=this.constants.strideX,r++)p+=e[this.thread.z][t][n]*i[this.constants.deltaZ][c][r]}return p}function Rt(t,e){let i=0;for(let t=0;t<this.constants.deltaHeight;t++)for(let r=0;r<this.constants.deltaWidth;r++)i+=e[this.thread.z][t][r];return t[this.thread.z][this.thread.y][this.thread.x]+i}const Ht={stride:0,padding:0,bias:.1,filterCount:1,filterWidth:0,filterHeight:0};class qt extends M{constructor(t,e){var i,r,n;super(t,e),this.compareFilterDeltasKernel=null,this.compareInputDeltasKernel=null,this.compareBiasesKernel=null,this.settings={...Ht,...t,...Dt(t,Ht),...Tt(t,Ht)},this.weights=null!==(i=t.weights)&&void 0!==i?i:bt(this.width,this.height,this.depth),this.deltas=E(this.width,this.height,this.depth),this.biases=jt(this.depth,this.bias),this.biasDeltas=null!==(r=t.biasDeltas)&&void 0!==r?r:mt(this.depth),this.filters=null!==(n=t.filters)&&void 0!==n?n:bt(this.filterWidth,this.filterHeight,this.filterCount),this.filterDeltas=E(this.filterWidth,this.filterHeight,this.filterCount),this.validate()}get strideX(){return this.settings.strideX}get strideY(){return this.settings.strideY}get paddingX(){return this.settings.paddingX}get paddingY(){return this.settings.paddingX}get width(){return Math.floor((this.inputLayer.width+2*this.paddingX-this.filterWidth)/this.strideX+1)}get height(){return Math.floor((this.inputLayer.height+2*this.paddingY-this.filterHeight)/this.strideY+1)}get bias(){return this.settings.bias}get depth(){return this.filterCount}get biases(){return this.settings.biases}set biases(t){this.settings.biases=t}get biasDeltas(){return this.settings.biasDeltas}set biasDeltas(t){this.settings.biasDeltas=t}get filters(){return this.settings.filters}set filters(t){this.settings.filters=t}get filterDeltas(){return this.settings.filterDeltas}set filterDeltas(t){this.settings.filterDeltas=t}setupKernels(){this.predictKernel=m(Ft,{constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,inputDepth:this.inputLayer.depth,strideX:this.strideX,strideY:this.strideY,paddingX:this.paddingX,paddingY:this.paddingY,filterWidth:this.filterWidth,filterHeight:this.filterHeight},output:[this.width,this.height,this.depth],immutable:!0}),this.compareFilterDeltasKernel=m(Nt,{constants:{deltasWidth:this.width,deltasHeight:this.height,deltasDepth:this.depth,inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,inputDepth:this.inputLayer.depth,strideX:this.strideX,strideY:this.strideY,paddingX:this.paddingX,paddingY:this.paddingY,filterWidth:this.filterWidth,filterHeight:this.filterHeight},output:[this.width,this.height,this.depth],immutable:!0}),this.compareInputDeltasKernel=m(Ct,{constants:{filterCount:this.filterCount},output:[this.inputLayer.width,this.inputLayer.height,this.inputLayer.depth],immutable:!0}),this.compareBiasesKernel=m(Rt,{output:[1,1,this.depth],constants:{deltaWidth:this.width,deltaHeight:this.height},immutable:!0})}predict(){this.weights=this.predictKernel(this.inputLayer.weights,this.filters,this.biases)}compare(){const{filterDeltas:t,biasDeltas:e}=this;this.filterDeltas=this.compareFilterDeltasKernel(t,this.inputLayer.weights,this.deltas),b(t),this.biasDeltas=this.compareBiasesKernel(e,this.deltas),b(e),b(this.deltas),this.deltas=this.compareInputDeltasKernel(this.filters,this.inputLayer.deltas),b(this.inputLayer.deltas),this.inputLayer.deltas=x(this.deltas)}learn(t){const{weights:e}=this;this.weights=this.praxis.run(this,t),b(e)}}function Wt(t){return t}function Xt(t){return Wt(Math.random())<this.constants.probability?0:t[this.thread.y][this.thread.x]}function Yt(t){return t[this.thread.y][this.thread.x]*this.constants.probability}function Jt(t,e){return 0===t[this.thread.y][this.thread.x]?0:e[this.thread.y][this.thread.x]}const Bt={...v,probability:.5};class Gt extends M{constructor(t,e){super(e,t),this.predictKernelMap=null,this.settings={...Bt,...e},this.dropouts=null,this.validate()}setupKernels(t){const e=[this.width,this.height];t?(this.predictKernelMap=L({dropouts:Wt},Xt,{output:e,immutable:!0}),this.compareKernel=m(Jt,{output:e,immutable:!0})):this.predictKernelMap=L({},Yt,{output:e,immutable:!0})}predict(){b(this.weights),this.dropouts&&b(this.dropouts);const{result:t,dropouts:e}=this.predictKernelMap(this.inputLayer.weights);this.weights=t,this.dropouts=e}compare(){b(this.deltas),this.deltas=this.compareKernel(this.dropouts,this.inputLayer.deltas)}}function Vt(t,e,i){let r=0,n=0;for(let i=0;i<this.constants.inputHeight;i++)for(let s=0;s<this.constants.inputWidth;s++)r+=t[i][s]*e[this.thread.x][n],n++;return r+i[this.thread.x]}function Ut(t,e,i){let r=0,n=0;for(let i=0;i<this.constants.inputDepth;i++)for(let s=0;s<this.constants.inputHeight;s++)for(let o=0;o<this.constants.inputWidth;o++)r+=t[i][s][o]*e[this.thread.x][n],n++;return r+i[this.thread.x]}function Zt(t,e,i){let r=0;const n=this.thread.x+this.thread.y*this.output.x;for(let t=0;t<this.constants.filterCount;t++)r+=i[t][n]*e[0][t];return r+t[this.thread.y][this.thread.x]}function Qt(t,e,i){let r=0;const n=this.thread.x+this.thread.y*this.output.x;for(let t=0;t<this.constants.filterCount;t++)r+=i[t][n]*e[0][t];return r+t[this.thread.z][this.thread.y][this.thread.x]}function te(t,e){return t[this.thread.x]+e[this.thread.y][this.thread.x]}function ee(t,e,i){return t[this.thread.y][this.thread.x]+e[this.thread.y][this.thread.x]*i[this.constants.deltaY][this.constants.deltaX]}function ie(t,e,i){const r=Math.floor(this.thread.x/(this.constants.inputWidth*this.constants.inputHeight)),n=Math.floor((this.thread.x-r*this.constants.inputWidth*this.constants.inputHeight)/this.constants.inputWidth),s=this.thread.x-this.constants.inputWidth*(n+this.constants.inputHeight*r);return t[this.thread.y][this.thread.x]+e[r][n][s]*i[0][this.thread.y]}class re extends M{constructor(t,e){super(t,e),this.compareFilterDeltasKernel=null,this.compareInputDeltasKernel=null,this.compareBiasesKernel=null,this.settings={...t},this.validate();const i=e.width*e.height*e.depth;this.biases=jt(this.height,this.bias),this.biasDeltas=I(this.height),this.filters=Lt(i,this.height),this.filterDeltas=z(i,this.height),this.depth>0?(this.weights=bt(this.width,this.height,this.depth),this.deltas=E(this.width,this.height,this.depth)):this.height>0&&(this.weights=Lt(this.width,this.height),this.deltas=z(this.width,this.height))}get bias(){return this.settings.bias}get biases(){return this.settings.biases}set biases(t){this.settings.biases=t}get biasDeltas(){return this.settings.biases}set biasDeltas(t){this.settings.biasDeltas=t}validate(){if(super.validate(),this.depth>0)throw new Error("depth not supported")}setupKernels(){const{inputLayer:t}=this,e=t.width*t.height*t.depth;t.depth>0?(this.predictKernel=m(Ut,{output:[this.width,this.height],constants:{inputHeight:t.height,inputWidth:t.width,inputDepth:t.depth}}),this.compareFilterDeltasKernel=m(ie,{output:[e,this.height],constants:{inputWidth:t.width,inputHeight:t.height},immutable:!0}),this.compareInputDeltasKernel=m(Qt,{output:[t.width,t.height,t.depth],constants:{filterCount:this.height},immutable:!0})):(this.predictKernel=m(Vt,{output:[this.width,this.height],constants:{inputHeight:t.height,inputWidth:t.width}}),this.compareFilterDeltasKernel=m(ee,{output:[e,this.height],constants:{inputWidth:t.width}}),this.compareInputDeltasKernel=m(Zt,{output:[t.width,t.height],constants:{filterCount:this.height}})),this.compareBiasesKernel=m(te,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights,this.filters,this.biases)}compare(){const t=this.inputLayer.deltas;this.inputLayer.deltas=this.compareInputDeltasKernel(t,this.deltas,this.filters),b(t);const{biasDeltas:e,filterDeltas:i}=this;this.biasDeltas=this.compareBiasesKernel(this.biases,this.deltas),this.filterDeltas=this.compareFilterDeltasKernel(i,this.inputLayer.weights,this.deltas),b(e),b(i)}}function ne(t){return-t[this.thread.y][this.thread.x]}class se extends _{constructor(t,e){super(t,e),this.validate()}setupKernels(){this.predictKernel=m(ne,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights)}}function oe(t,e){return new se(t,e)}function he(t,e){return t[this.thread.y][this.thread.x]*e[this.thread.y][this.thread.x]}function ae(t,e){return t[this.thread.y][this.thread.x]*e[this.thread.y][this.thread.x]}class ue extends K{get width(){return this.inputLayer1.width}get height(){return this.inputLayer1.height}get depth(){return this.inputLayer1.depth}validate(){super.validate(),lt(this.inputLayer1,this.inputLayer2)}setupKernels(){this.predictKernel=m(he,{output:[this.width,this.height],immutable:!0}),this.compareKernel=m(ae,{output:[this.width,this.height],immutable:!0})}predict(){b(this.weights),this.weights=this.predictKernel(this.inputLayer1.weights,this.inputLayer2.weights)}compare(){b(this.inputLayer1.deltas),b(this.inputLayer2.deltas),this.inputLayer1.deltas=this.compareKernel(this.inputLayer2.weights,this.deltas),this.inputLayer2.deltas=this.compareKernel(this.inputLayer1.weights,this.deltas)}}function le(t,e,i){return new ue(t,e,i)}function pe(t){return new Float32Array(t).fill(1)}function ce(t,e){const i=new Array(e);for(let r=0;r<e;r++)i[r]=pe(t);return i}class de extends R{constructor(t){super(t),this.validate(),this.weights=ce(this.width,this.height),this.deltas=z(this.width,this.height)}}function ge(t){return new de(t)}function fe(t){return a(t[this.thread.y][this.thread.x])}function we(t){return a(t[this.thread.z][this.thread.y][this.thread.x])}function ye(t,e){return u(t[this.thread.y][this.thread.x],e[this.thread.y][this.thread.x])}function me(t,e){return u(t[this.thread.z][this.thread.y][this.thread.x],e[this.thread.z][this.thread.y][this.thread.x])}class Le extends ${setupKernels(){this.depth>0?(this.predictKernel=m(we,{output:[this.width,this.height,this.depth],functions:[a],immutable:!0}),this.compareKernel=m(me,{output:[this.width,this.height,this.depth],functions:[u],immutable:!0})):(this.predictKernel=m(fe,{output:[this.width,this.height],functions:[a],immutable:!0}),this.compareKernel=m(ye,{output:[this.width,this.height],functions:[u],immutable:!0}))}predict(){b(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){b(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}}function be(t,e){return new Le(t,e)}class xe extends R{constructor(t){super(t),this.validate(),this.weights=z(this.width,this.height),this.deltas=z(this.width,this.height)}predict(){}compare(){}}function ke(t){return new xe(t)}const Oe={weights:null};class ve extends C{constructor(t){super({...Oe,...t}),this.reshapeInput=null,this.validate(),this.reshapeInput=null,this.deltas=z(this.width,this.height)}setupKernels(){1===this.width&&(this.predict=this.predict1D,this.reshapeInput=m(function(t){return t[this.thread.y]},{output:[1,this.height],immutable:!0}))}reuseKernels(t){this.reshapeInput=t.reshapeInput}predict(t){if((Array.isArray(t)||t instanceof Float32Array)&&"number"==typeof t[0]&&t.length===this.height*this.width)b(this.weights),this.weights=(i=t,r=[this.width,this.height],new e.Input(i,r));else{if(!Array.isArray(t)||t.length!==this.height||!(Array.isArray(t[0])||t[0]instanceof Float32Array)||t[0].length!==this.width)throw new Error("Inputs are not of sized correctly");this.weights=x(t)}var i,r}predict1D(t){this.weights&&b(this.weights),this.reshapeInput?this.weights=this.reshapeInput(t):this.weights=t}compare(){}learn(){}}function Ae(t){return p(t[this.thread.y][this.thread.x])}function Se(t){return p(t[this.thread.z][this.thread.y][this.thread.x])}function Ie(t,e){return c(t[this.thread.y][this.thread.x],e[this.thread.y][this.thread.x])}function ze(t,e){return c(t[this.thread.z][this.thread.y][this.thread.x],e[this.thread.z][this.thread.y][this.thread.x])}class Ee extends ${setupKernels(){const{width:t,height:e,depth:i}=this.inputLayer;this.depth>0?(this.predictKernel=m(Se,{output:[t,e,i],functions:[p],immutable:!0}),this.compareKernel=m(ze,{output:[t,e,i],functions:[c],immutable:!0})):(this.predictKernel=m(Ae,{output:[t,e],functions:[p],immutable:!0}),this.compareKernel=m(Ie,{output:[t,e],functions:[c],immutable:!0}))}predict(){b(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){const{deltas:t}=this;this.deltas=this.compareKernel(this.weights,t),b(t)}}function $e(t){return t}function Me(t){return t}function Pe(t){const e=this.constants.paddingX-this.thread.x*this.constants.strideX,i=this.thread.x*this.constants.strideX-this.constants.paddingX,r=Math.min(this.constants.filterWidth,e+this.constants.inputWidth),n=this.constants.paddingY-this.thread.y*this.constants.strideY,s=this.thread.y*this.constants.strideY-this.constants.paddingY,o=Math.min(this.constants.filterHeight,n+this.constants.inputHeight);let h=-99999;for(let a=Math.max(0,n),u=Math.max(0,s);a<o;a++,u++)for(let n=Math.max(0,e),s=Math.max(0,i);n<r;n++,s++)if(u>=0&&u<this.constants.inputHeight&&s>=0&&s<this.constants.inputWidth){const e=t[this.thread.z][u][s];e>h&&(h=e)}return h}function _e(t,e,i){const r=Math.floor(this.thread.x/this.output.x*this.constants.outputWidth),n=Math.floor(this.thread.y/this.output.y*this.constants.outputHeight);let s=0;for(let o=0;o<this.constants.inputHeight;o++)for(let h=0;h<this.constants.inputWidth;h++){const a=i[o][h],u=e[o][h];a===r&&u===n&&(s+=t[o][h])}return s}const Ke={padding:0,stride:0,filterWidth:0,filterHeight:0,filterCount:0};class Te extends M{constructor(t,e){super(t,e),this.predictKernelMap=null,this.settings={...t,...Tt(t,Ke),...Dt(t,Ke)},this.weights=bt(this.width,this.height,this.depth),this.deltas=E(this.width,this.height,this.depth),this.filters=bt(this.filterWidth,this.filterHeight,this.filterCount),this.filterDeltas=E(this.filterWidth,this.filterHeight,this.filterCount),this.validate()}get strideX(){return this.settings.strideX}get strideY(){return this.settings.strideY}get paddingX(){return this.settings.paddingX}get paddingY(){return this.settings.paddingY}get width(){return Math.floor((this.inputLayer.width+2*this.paddingX-this.filterWidth)/this.strideX+1)}get height(){return Math.floor((this.inputLayer.height+2*this.paddingY-this.filterHeight)/this.strideY+1)}get depth(){return this.settings.filterCount}get filterCount(){return this.settings.filterCount}get switchX(){return this.settings.switchX}set switchX(t){this.settings.switchX=t}get switchY(){return this.settings.switchY}set switchY(t){this.settings.switchY=t}setupKernels(){this.predictKernelMap=L({switchX:Me,switchY:$e},Pe,{output:[this.width,this.height,this.depth],constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,paddingX:this.paddingX,paddingY:this.paddingY,filterHeight:this.filterHeight,filterWidth:this.filterWidth}}),this.compareKernel=m(_e,{output:[this.inputLayer.width,this.inputLayer.height,this.inputLayer.depth],constants:{inputWidth:this.inputLayer.width,inputHeight:this.inputLayer.height,outputWidth:this.width,outputHeight:this.height}})}predict(){const{result:t,switchX:e,switchY:i}=this.predictKernelMap(this.inputLayer.weights);this.switchX=e,this.switchY=i,this.weights=t}compare(){const t=this.inputLayer.deltas;this.inputLayer.deltas=this.compareKernel(this.deltas,this.switchX,this.switchY),b(t)}}class De extends P{constructor(t){super(),this.praxis=null,this.predictKernel=null,this.compareKernel=null,this.settings={},this.recurrentInput=t,this.validate()}get width(){return this.recurrentInput.width}get height(){return this.recurrentInput.height}get depth(){return this.recurrentInput.depth}get deltas(){return this.recurrentInput.deltas}set deltas(t){const e=this.recurrentInput.deltas;this.recurrentInput.deltas=t,b(e)}get weights(){return this.recurrentInput.weights}set weights(t){const e=this.recurrentInput.weights;this.recurrentInput.weights=t,b(e)}validate(){if(A.prototype.validate.call(this),this.width!==this.recurrentInput.width)throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);if(this.height!==this.recurrentInput.height)throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`)}setDimensions(t,e){this.recurrentInput.width=t,this.recurrentInput.height=e}predict(){}compare(){}learn(){}setupKernels(){}reuseKernels(){}}class je extends P{constructor(t){super(),this.praxis=null,this.settings={},this.predictKernel=null,this.compareKernel=null,t&&(this.settings={...t})}setDimensions(t,e){this.praxis=null,this.settings={...this.settings,width:t,height:e,weights:z(t,e),deltas:z(t,e)}}setupKernels(){}reuseKernels(){}predict(){}compare(){}learn(t){const{weights:e}=this;this.weights=this.praxis.run(this,t),b(e)}}function Fe(){return new je}function Ne(t){return i(t[this.thread.y][this.thread.x])}function Ce(t,e){return r(t[this.thread.y][this.thread.x],e[this.thread.y][this.thread.x])}function Re(t){return i(t[this.thread.z][this.thread.y][this.thread.x])}function He(t,e){return r(t[this.thread.z][this.thread.y][this.thread.x],e[this.thread.z][this.thread.y][this.thread.x])}class qe extends ${setupKernels(){const{width:t,height:e,depth:n}=this.inputLayer;n>0?(this.predictKernel=m(Re,{output:[t,e,n],functions:[i],immutable:!0}),this.compareKernel=m(He,{output:[t,e,n],functions:[r],immutable:!0})):(this.predictKernel=m(Ne,{output:[t,e],functions:[i],immutable:!0}),this.compareKernel=m(Ce,{output:[t,e],functions:[r],immutable:!0}))}predict(){b(this.weights),this.weights=this.predictKernel(this.inputLayer.weights)}compare(){b(this.inputLayer.deltas),this.inputLayer.deltas=this.compareKernel(this.weights,this.deltas)}}function We(t,e){return new qe(t,e)}class Xe extends A{constructor(t,e){super(t),this.inputLayer=e,this.validate()}predict(){b(this.weights),this.weights=x(this.inputLayer.weights)}learn(){}}function Ye(t){let e=-1/0;for(let i=0;i<this.constants.inputHeight;i++)for(let r=0;r<this.constants.inputWidth;r++){const n=t[i][r];n>e&&(e=n)}return e}function Je(t){let e=-1/0;for(let i=0;i<this.constants.inputDepth;i++)for(let r=0;r<this.constants.inputHeight;r++)for(let n=0;n<this.constants.inputWidth;n++){const s=t[i][r][n];s>e&&(e=s)}return e}function Be(t){let e=0;for(let i=0;i<this.constants.inputHeight;i++)for(let r=0;r<this.constants.inputWidth;r++)e+=t[i][r];return e}function Ge(t){let e=0;for(let i=0;i<this.constants.inputDepth;i++)for(let r=0;r<this.constants.inputHeight;r++)for(let n=0;n<this.constants.inputWidth;n++)e+=t[i][r][n];return e}function Ve(t,e){return Math.exp(t[this.thread.x]-e[0])}function Ue(t,e){return Math.exp(t[this.thread.z][this.thread.y][this.thread.x]-e[0])}function Ze(t,e){return t[this.thread.y][this.thread.x]/e[0]}function Qe(t,e){return t[this.thread.z][this.thread.y][this.thread.x]/e[0]}function ti(t,e){let i=0;return this.thread.x+this.thread.y*this.output.x===t&&(i=1),-(i-e[this.thread.y][this.thread.x])}function ei(t,e){let i=0;return this.thread.x+this.thread.y*this.output.x+this.thread.z*this.output.x*this.output.y===t&&(i=1),-(i-e[this.thread.z][this.thread.y][this.thread.x])}class ii extends _{constructor(t,e){super(t,e),this.errors=null,this.getExponentialsKernel=null,this.getMaxValueKernel=null,this.getSumKernel=null,this.validate(),this.depth>0?(this.weights=bt(this.width,this.height,this.depth),this.deltas=E(this.width,this.height,this.depth)):this.height>0?(this.weights=Lt(this.width,this.height),this.deltas=z(this.width,this.height)):(this.weights=mt(this.width),this.deltas=I(this.width))}setupKernels(){const{width:t,height:e,depth:i}=this;i>0?(this.getExponentialsKernel=m(Ue,{output:[t,e,i]}),this.getMaxValueKernel=m(Je,{output:[1,1,1],constants:{inputWidth:t,inputHeight:e,inputDepth:i}}),this.getSumKernel=m(Ge,{output:[1,1,1],constants:{inputWidth:t,inputHeight:e,inputDepth:i}}),this.predictKernel=m(Qe,{output:[t,e,i]}),this.compareKernel=m(ei,{output:[t,e,i],immutable:!0})):(this.getExponentialsKernel=m(Ve,{output:[t,e]}),this.getMaxValueKernel=m(Ye,{output:[1,1],constants:{inputWidth:t,inputHeight:e}}),this.getSumKernel=m(Be,{output:[1,1],constants:{inputWidth:t,inputHeight:e}}),this.predictKernel=m(Ze,{output:[t,e]}),this.compareKernel=m(ti,{output:[t,e],immutable:!0}))}predict(){const t=this.getMaxValueKernel(this.inputLayer.weights),e=this.getExponentialsKernel(this.inputLayer.weights,t),i=this.getSumKernel(e);this.weights=this.predictKernel(e,i)}compare(t){const{deltas:e,errors:i}=this;this.errors=this.compareKernel(t[0],e),this.deltas=x(this.errors),b(e),b(i);const r=this.inputLayer.deltas;this.inputLayer.deltas=x(this.deltas),b(r)}}class ri extends A{constructor(t,e){super(e),this.inputLayer=t}predict(){b(this.weights),this.weights=x(this.inputLayer.weights),this.validate()}learn(){}}function ni(t){return t[this.thread.x][this.thread.y]}const si=ni;class oi extends _{get width(){return this.inputLayer.height}get height(){return this.inputLayer.width}constructor(t){super(t),this.validate()}setupKernels(){this.predictKernel=m(ni,{output:[this.height,this.width]}),this.compareKernel=m(si,{output:[this.width,this.height]})}predict(){this.weights=this.predictKernel(this.inputLayer.weights)}compare(){this.inputLayer.deltas=this.compareKernel(this.deltas)}}const hi={Activation:$,Internal:P,InternalModel:N,EntryPoint:C,Filter:M,Model:R,Modifier:_,Operator:K,Target:j};var ai=Object.freeze({__proto__:null,layerTypes:hi,Add:ct,add:dt,arthurFeedForward:function(t,e){const{height:i}=t,r=Ot({id:"weights",height:i,width:e.height,initPraxis:function(t,e){const i=Z(t,e);return i.setupKernels(),i}}),n=Ot({id:"biases",height:i,initPraxis:function(t,e){const i=J(t,e);return i.setupKernels(),i}}),s=Kt(dt(zt(r,e),n)),o=r.praxis;return o.weightsLayer=r,o.incomingLayer=e,o.deltaLayer=s,s},BaseLayer:A,baseLayerDefaultSettings:v,Convolution:qt,convolution:function(t,e){return new qt(t,e)},Dropout:Gt,dropout:function(t,e){return new Gt(t,e)},feedForward:function(t,e){const{height:i,praxisOpts:r=null}=t,n=Ot({id:"weights",height:i,width:e.height,praxisOpts:r}),s=Ot({id:"biases",height:i,praxisOpts:r});return Kt(dt(zt(n,e,{praxisOpts:r}),s,{praxisOpts:r}),{praxisOpts:r})},FullyConnected:re,fullyConnected:function(t,e){return new re(t,e)},gru:function(t,e,i){const{height:r}=t,n=Ot({height:r,width:i.height}),s=Ot({width:r,height:r}),o=ke({height:r}),h=Kt(dt(dt(zt(n,i),zt(s,e)),o)),a=Ot({height:r,width:i.height}),u=Ot({width:r,height:r}),l=ke({height:r}),p=Kt(dt(dt(zt(a,i),zt(u,e)),l)),c=Ot({height:r,width:i.height}),d=Ot({width:r,height:r}),g=ke({height:r}),f=be(dt(dt(zt(c,i),zt(d,le(p,e))),g));return dt(le(dt(ge({width:h.width,height:h.height}),oe(h)),f),le(e,h))},Input:ve,input:function(t){return new ve(t)},LeakyRelu:Ee,leakyRelu:function(t,e){return new Ee(t,e)},lstmCell:function(t,e,i){const{height:r}=t;if("number"!=typeof r)throw new Error("no settings.height given");i.setDimensions&&i.setDimensions(1,r);const n=Ot({width:e.height,height:r,std:.08,id:"inputGateWeights"}),s=Ot({width:r,height:r,std:.08,id:"inputGatePeepholes"}),o=ke({width:1,height:r,id:"inputGateBias"}),h=Kt(dt(dt(zt(n,e),zt(s,i)),o),{id:"inputGate"}),a=Ot({width:e.height,height:r,std:.08,id:"forgetGateWeights"}),u=Ot({width:r,height:r,std:.08,id:"forgetGatePeepholes"}),l=ke({width:1,height:r,id:"forgetGateBias"}),p=Kt(dt(dt(zt(a,e),zt(u,i)),l),{id:"forgetGate"}),c=Ot({width:e.height,height:r,std:.08,id:"outputGateWeights"}),d=Ot({width:r,height:r,std:.08,id:"outputGatePeepholes"}),g=ke({width:1,height:r,id:"outputGateBias"}),f=Kt(dt(dt(zt(c,e),zt(d,i)),g),{id:"outputGate"}),w=Ot({width:e.height,height:r,std:.08,id:"memoryWeights"}),y=Ot({width:r,height:r,std:.08,id:"memoryPeepholes"}),m=ke({width:1,height:r,id:"memoryBias"}),L=be(dt(dt(zt(w,e),zt(y,i)),m),{id:"memory"}),b=le(p,i,{id:"retainCell"}),x=le(h,L,{id:"writeCell"});return le(f,be(dt(b,x,{id:"cell"})),{id:"activations"})},Multiply:It,multiply:zt,MultiplyElement:ue,multiplyElement:le,Negative:se,negative:oe,Ones:de,ones:ge,output:function(t,e){const{height:i}=t,r=Ot({height:i,width:e.height,id:"outputGate",std:.08}),n=Ot({height:i,id:"output",std:.08}),s=zt(r,e,{id:"outputGateConnected"});return F({id:"target",...t},dt(s,n))},Pool:Te,pool:function(t,e){return new Te(t,e)},Random:kt,random:Ot,RecurrentInput:De,RecurrentZeros:je,rnnCell:function(t,e,i){const{height:r}=t;if("number"!=typeof r)throw new Error("height not set");i.setDimensions&&i.setDimensions(1,r);const n=Ot({id:"weight",height:r,width:e.height,std:.08}),s=Ot({id:"transition",height:r,width:r,std:.08}),o=ke({id:"bias",height:r});return We(dt(dt(zt(n,e),zt(s,i)),o))},Regression:Xe,regression:function(t,e){return new Xe(t,e)},Relu:qe,relu:We,Sigmoid:_t,sigmoid:Kt,SoftMax:ii,softMax:function(t,e){return new ii(t,e)},SVM:ri,svm:function(t,e){return new ri(t,e)},Tanh:Le,tanh:be,Target:j,target:F,Transpose:oi,transpose:function(t){return new oi(t)},Zeros:xe,zeros:ke});const ui=Object.keys(ai);function li(t,e,i){if(!ui.find(e=>e===t.type))return null;const r=ai[t.type];if(r.prototype instanceof hi.Filter){if(!e)throw new Error("inputLayer missing");return new r(t,e)}if(r.prototype instanceof hi.Activation||r.prototype instanceof hi.Modifier){if(!e)throw new Error("inputLayer missing");return new r(e,t)}if(r.prototype instanceof hi.Internal)return new r(t);if(r.prototype instanceof hi.Operator){if(!e)throw new Error("inputLayer1 missing");if(!i)throw new Error("inputLayer2 missing");return new r(e,i,t)}if(r.prototype instanceof hi.InternalModel||r.prototype instanceof hi.EntryPoint||r.prototype instanceof hi.Model)return new r(t);if(r===j){if(!e)throw new Error("inputLayer missing");return new r(t,e)}return null}class pi{constructor(t,e){this.prop=null,this.table={},this.length=0;const i=this.table;if(e){this.prop=e;for(let r=0;r<t.length;r++){const n=t[r][e];for(const t in n)n.hasOwnProperty(t)&&(i.hasOwnProperty(t)||(i[t]=this.length++))}}else if(Array.isArray(t)&&Array.isArray(t[0]))for(let e=0;e<t.length;e++){const r=t[e];for(let t=0;t<r.length;t++){const e=r[t];for(const t in e)e.hasOwnProperty(t)&&(i.hasOwnProperty(t)||(i[t]=this.length++))}}else for(let e=0;e<t.length;e++){const r=t[e];for(const t in r)r.hasOwnProperty(t)&&(i.hasOwnProperty(t)||(i[t]=this.length++))}}}const ci={learningRate:.3,binaryThresh:.5,initPraxis:(t,e)=>{var i;return nt(t,null!==(i=t.settings.praxisOpts)&&void 0!==i?i:e)}},di={iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,learningRate:.3,callbackPeriod:10,errorCheckInterval:100,timeout:1/0};class gi{constructor(t={}){this.trainOpts={},this.layers=null,this._inputLayer=null,this._hiddenLayers=null,this._outputLayer=null,this._model=null,this.meanSquaredError=null,this.inputLookup=null,this.inputLookupLength=null,this.outputLookup=null,this.outputLookupLength=null,this.options={...ci,...t},this._updateTrainingOptions({...di,...t})}static _validateTrainingOptions(t){const{iterations:e,errorThresh:i,log:r,logPeriod:n,learningRate:s,callback:o,callbackPeriod:h,timeout:a}=t,u={iterations:()=>"number"==typeof e&&e>0,errorThresh:()=>"number"==typeof i&&i>0&&i<1,log:()=>"function"==typeof r||"boolean"==typeof r,logPeriod:()=>"number"==typeof n&&n>0,learningRate:()=>"number"==typeof s&&s>0&&s<1,callback:()=>"function"==typeof o||null===o,callbackPeriod:()=>"number"==typeof h&&h>0,timeout:()=>"number"==typeof a&&a>0};Object.keys(di).forEach(e=>{if(u.hasOwnProperty(e)&&!u[e]()){const i=t[e];throw new Error(`[${e}, ${(null!=i?i:"undefined").toString()}] is out of normal training range, your network will probably not train.`)}})}_setLogMethod(t){this.trainOpts.log="function"==typeof t?t:!!t&&console.log}_updateTrainingOptions(t){var e;this.trainOpts={...di,...this.trainOpts,...t},gi._validateTrainingOptions(this.trainOpts),this._setLogMethod(null!==(e=t.log)&&void 0!==e?e:this.trainOpts.log);const{callback:i,callbackPeriod:r,errorCheckInterval:n}=this.trainOpts;i&&r!==n&&console.warn(`options.callbackPeriod with value of ${(null!=r?r:"undefined").toString()} does not match options.errorCheckInterval with value of ${(null!=n?n:"undefined").toString()}, if logging error, it will repeat.  These values may need to match`)}_connectOptionsLayers(){const{inputLayerIndex:t,outputLayerIndex:e,layers:i}=this.options;if(!i)throw new Error("this.options.layers in unexpected state");if("number"!=typeof t)throw new Error("inputLayerIndex not a number");if("number"!=typeof e)throw new Error("inputLayerIndex not a number");const r=i[t];if(!r)throw new Error("inputLayer not found in this.options.layers");const n=i[e];if(!n)throw new Error("outputLayer not found in this.options.layers");return this._inputLayer=r,this._hiddenLayers=i.slice(t,e-t),this._outputLayer=n,i}_connectNewLayers(){const{inputLayer:t,outputLayer:e}=this.options;if(!t)throw new Error("inputLayer not defined");const i=[];this._inputLayer=t();const r=this._connectHiddenLayers(this._inputLayer);if(!e)throw new Error("outputLayer not defined");return this._outputLayer=e(r[r.length-1],r.length),i.push(this._inputLayer),i.push(...r),i.push(this._outputLayer),ut(i)}_connectHiddenLayers(t){this._hiddenLayers=[];const e=[],{hiddenLayers:i}=this.options;if(!i)throw new Error("hiddenLayers not defined");for(let r=0;r<i.length;r++){const n=i[r](t,r);e.push(n),this._hiddenLayers.push(n),t=n}return e}initialize(){this.layers=this.options.layers?this._connectOptionsLayers():this._connectNewLayers(),this.initializeLayers(this.layers),this._model=this.layers.filter(t=>t instanceof R)}initializeLayers(t){var e,i;for(let r=0;r<t.length;r++){const n=t[r];n.setupKernels(!0),n instanceof R&&null===n.praxis&&"function"==typeof this.options.initPraxis&&(n.praxis=this.options.initPraxis(n,null!==(i=null!==(e=n.settings.praxisOpts)&&void 0!==e?e:this.options.praxisOpts)&&void 0!==i?i:{}),n.praxis.setupKernels())}const r=t[t.length-1];this.meanSquaredError=new O({width:r.width,height:r.height})}run(t){let i;if(Array.isArray(t)||t.buffer)i=t;else{if(!this.inputLookup)throw new Error("input is incompatible with net");i=H.toArray(this.inputLookup,t,this.inputLookupLength)}let r=this.runInput(i);return r instanceof e.Texture&&(r=r.toArray()),this.outputLookup?H.toObject(this.outputLookup,r):r}runInput(t){if(!this.layers)throw new Error("not initialized");this.layers[0].predict(t);for(let t=1;t<this.layers.length;t++)this.layers[t].predict();return this.layers[this.layers.length-1].weights}train(t,e={}){const{preparedData:i,status:r,endTime:n}=this._prepTraining(t,e);let s=!0;const o=()=>this._calculateTrainingError(i),h=()=>this._trainPatterns(i);for(;s;)s=this._trainingTick(r,n,o,h);return r}_trainingTick(t,e,i,r){const{trainOpts:n}=this;return!(t.iterations>=n.iterations||t.error<=n.errorThresh||Date.now()>=e)&&("function"==typeof n.log&&t.iterations%n.logPeriod==0?(t.error=i(),n.log(`iterations: ${t.iterations}, training error: ${t.error}`)):t.iterations%n.errorCheckInterval==0?t.error=i():r(),n.callback&&t.iterations%n.callbackPeriod==0&&n.callback(Object.assign(t)),t.iterations++,!0)}_prepTraining(t,e){this._updateTrainingOptions(e);const i=this.formatData(t),r=this.trainOpts.timeout?Date.now()+this.trainOpts.timeout:0;return this.verifyIsInitialized(),{preparedData:this.transferData(i),status:{error:1,iterations:0},endTime:r}}verifyIsInitialized(){this._model||this.initialize()}_calculateTrainingError(t){let i=new Float32Array([0]);const r=this.meanSquaredError;for(let e=0;e<t.length;++e){const n=i,s=this._trainPattern(t[e].input,t[e].output,!0);i=r.add(i,s),b(s),b(n)}const n=r.divide(t.length,i);if(b(i),n instanceof e.Texture){const t=n.toArray();return b(n),t[0]}return n[0]}_trainPatterns(t){for(let e=0;e<t.length;++e)this._trainPattern(t[e].input,t[e].output,!1)}_trainPattern(t,e,i){var r;if(this.runInput(t),this._calculateDeltas(e),this.adjustWeights(),i){if(!(null===(r=this._outputLayer)||void 0===r?void 0:r.errors))throw new Error("outputLayer.errors not defined");return this.meanSquaredError.calculate(this._outputLayer.errors)}return null}_calculateDeltas(t){const e=this.layers;for(let i=e.length-1;i>-1;i--)e[i].compare(t)}adjustWeights(){const t=this._model;for(let e=0;e<t.length;e++)t[e].learn(this.trainOpts.learningRate)}formatData(t){if(!Array.isArray(t)){const e=[];e.push(t),t=e}const e=t[0].input;let i;if(!Array.isArray(t)||Array.isArray(e)||e instanceof Float32Array)i=t;else{if(!this.inputLookup){const e=new pi(t,"input");this.inputLookup=e.table,this.inputLookupLength=e.length}i=t.map(t=>{return{input:H.toArray(this.inputLookup,t.input,this.inputLookupLength)}},this)}const r=t[0].output;if(!(Array.isArray(r)||r instanceof Float32Array)){if(!this.outputLookup){const e=new pi(t,"output");this.outputLookup=e.table,this.outputLookupLength=e.length}i=t.map((t,e)=>{const r=H.toArray(this.outputLookup,t.output,this.inputLookupLength);return{input:i[e].input,output:r}},this)}return i}transferData(t){const e=new Array(t.length),i=m(function(t){return t[this.thread.x]},{output:[t[0].input.length],immutable:!0}),r=m(function(t){return t[this.thread.x]},{output:[t[0].output.length],immutable:!0});for(let n=0;n<t.length;n++){const s=t[n];e[n]={input:i(s.input),output:r(s.output)}}return e}test(){throw new Error(`${this.constructor.name}-test is not yet implemented`)}toJSON(){var t;if(this.layers||this.initialize(),!(this._model&&this.layers&&this._inputLayer&&this._hiddenLayers&&this._outputLayer))throw new Error("network is not initialized");const e=[];for(let t=0;t<this.layers.length;t++){const i=this.layers[t],r=i.toJSON();i.hasOwnProperty("inputLayer")?r.inputLayerIndex=this.layers.indexOf(i.inputLayer):i.hasOwnProperty("inputLayer1")&&i.hasOwnProperty("inputLayer2")&&(r.inputLayer1Index=this.layers.indexOf(i.inputLayer1),r.inputLayer2Index=this.layers.indexOf(i.inputLayer2)),e.push(r)}return{type:this.constructor.name,sizes:null!==(t=this.options.sizes)&&void 0!==t?t:[this._inputLayer.height].concat(this._hiddenLayers.map(t=>t.height)).concat([this._outputLayer.height]),outputLayerIndex:this.layers.indexOf(this._outputLayer),layers:e,inputLayerIndex:this.layers.indexOf(this._inputLayer)}}static fromJSON(t,e){var i,r,n,s;const o=t.layers,h=[],a=e?null!==(i=li(o[0]))&&void 0!==i?i:e(o[0]):li(o[0]);if(!a)throw new Error("unable to find layer");h.push(a);for(let t=1;t<o.length;t++){const i=o[t];if(void 0===i.inputLayerIndex&&void 0===i.inputLayer1Index&&void 0===i.inputLayer2Index){const t=e?null!==(r=li(i))&&void 0!==r?r:e(i):li(i);if(!t)throw new Error("unable to find layer");h.push(t)}else if("number"==typeof i.inputLayerIndex){const t=h[i.inputLayerIndex];if(!t)throw new Error("inputLayer1 not found");const r=e?null!==(n=li(i,t))&&void 0!==n?n:e(i,t):li(i,t);if(!r)throw new Error("unable to find layer");h.push(r)}else{if("number"!=typeof i.inputLayer1Index)throw new Error("Cannot create network from provided JSON. inputLayer1Index not defined.");if("number"!=typeof i.inputLayer2Index)throw new Error("Cannot create network from provided JSON. inputLayer2Index not defined.");const t=h[i.inputLayer1Index],r=h[i.inputLayer2Index];if(void 0===t)throw new Error(`Cannot create network from provided JSON. layer of index ${i.inputLayer1Index} not found.`);if(void 0===r)throw new Error(`Cannot create network from provided JSON. layer of index ${i.inputLayer2Index} not found.`);const n=e?null!==(s=li(i,t,r))&&void 0!==s?s:e(i,t,r):li(i,t,r);if(!n)throw new Error("unable to find layer");h.push(n)}}return new this({...t,layers:h})}toFunction(){throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)}createTrainStream(){throw new Error(`${this.constructor.name}-createTrainStream is not yet implemented`)}}var fi="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var wi,yi,mi=(function(t,e){var i=fi&&fi.__assign||function(){return(i=Object.assign||function(t){for(var e,i=1,r=arguments.length;i<r;i++)for(var n in e=arguments[i])Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}).apply(this,arguments)};Object.defineProperty(e,"__esModule",{value:!0}),e.thaw=e.Block=e.Thaw=void 0;var r=function(){function t(e,r){var n=this;void 0===r&&(r={});var s=i(i({},t.defaultSettings),r),o=s.each,h=s.done;this.i=0,this.isStopped=!1,this.items=e,this.options=r,this.tick=function(){if(!n.isStopped&&(n.timeout=setTimeout(n.tick,0),!t.thawing)){var e=n.items[n.i];if(n.i>=n.items.length)return null!==h&&(t.thawing=!0,h(),t.thawing=!1),n.isStopped=!0,void clearTimeout(n.timeout);null!==o?(t.thawing=!0,o(e,n.i),t.thawing=!1):void 0!==e&&e(),n.i++}},t.thaws.push(this),r.delay||this.tick()}return Object.defineProperty(t,"isThawing",{get:function(){return t.thawing},enumerable:!1,configurable:!0}),t.stopAll=function(){for(var e=0;e<t.thaws.length;e++)t.thaws[e].stop()},t.prototype.makeReady=function(){return!!this.isStopped&&(this.isStopped=!1,!0)},t.prototype.add=function(t){return this.items.push(t),this.makeReady()&&this.tick(),this},t.prototype.insert=function(t){return this.items.splice(this.i,0,t),this.makeReady()&&this.tick(),this},t.prototype.addArray=function(t){return this.items=this.items.concat(t),this.makeReady()&&this.tick(),this},t.prototype.insertArray=function(t){var e=this.items.splice(0,this.i),i=this.items;return this.items=e.concat(t,i),this.makeReady()&&this.tick(),this},t.prototype.stop=function(){return this.isStopped=!0,clearTimeout(this.timeout),this.options.done&&this.options.done(),this},t.thawing=!1,t.thaws=[],t.defaultSettings={each:null,done:null},t}();function n(t,e){return new r(t,e)}e.Thaw=r,e.thaw=n;var s=function(){function t(t,e){void 0===e&&(e=200),this.index=0,this.thaws=[],this.count=e,this.options=t}return t.prototype.add=function(t){return this.next().add(t),this},t.prototype.addArray=function(t){return this.next().addArray(t),this},t.prototype.insert=function(t){return this.next().insert(t),this},t.prototype.insertArray=function(t){return this.next().insertArray(t),this},t.prototype.stop=function(){for(var t=0;t<this.thaws.length;t++)this.thaws[t].stop();return this},t.prototype.next=function(){var t,e=this.thaws;return e.length<this.count?(t=new r([],this.options),e.push(t)):t=e[this.index]||null,this.index++,this.index>=this.count&&(this.index=0),t},t}();e.Block=s,"undefined"!=typeof window&&(window.Thaw=r,window.thaw=n,window.Thaw.Block=s)}(yi={path:wi,exports:{},require:function(t,e){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==e&&yi.path)}},yi.exports),yi.exports);function Li(t){const e=[];for(let i=0;i<t.length;i++)e.push(Float32Array.from(t[i]));return e}function bi(t,e){const i=[];for(let e=0;e<t.length;e++)i.push(Float32Array.from(t[e]));for(let t=0;t<e.length;t++)i.push(Float32Array.from(e[t]));return i}function xi(t){const e=[];for(let i=0;i<t.length;i++)e.push(Float32Array.from([t[i]]));return e}function ki(t,e){const i=[];for(let e=0;e<t.length;e++)i.push(Float32Array.from([t[e]]));for(let t=0;t<e.length;t++)i.push(Float32Array.from([e[t]]));return i}function Oi(t){return Float32Array.from(t)}function vi(t,e,i,r,n,s){const o=[];for(let e=0;e<t.length;e++){const r=t[e],s=new Float32Array(n);for(const t in r)r.hasOwnProperty(t)&&(s[i[t]]=r[t]);o.push(s)}for(let t=0;t<e.length;t++){const i=e[t],n=new Float32Array(s);for(const t in i)i.hasOwnProperty(t)&&(n[r[t]]=i[t]);o.push(n)}return o}function Ai(t){const e=[];for(const i in t)t.hasOwnProperty(i)&&e.push(Float32Array.from([t[i]]));return e}function Si(t,e){const i=[];for(const e in t)t.hasOwnProperty(e)&&i.push(Float32Array.from([t[e]]));for(const t in e)e.hasOwnProperty(t)&&i.push(Float32Array.from([e[t]]));return i}function Ii(t,e,i){const r=new Float32Array(i);for(const i in t)t.hasOwnProperty(i)&&(r[e[i]]=t[i]);return r}function zi(t){return Array.isArray(t)||t instanceof Float32Array?Math.max(...t):Math.max(...Object.values(t))}function Ei(t){let e=0;for(let i=0;i<t.length;i++)e+=t[i]**2;return e/t.length}function $i(t,e){if(t.buffer instanceof ArrayBuffer)return null;if(Array.isArray(t))return Oi;if(!e)throw new Error("table is not Object");const{length:i}=Object.keys(e);return t=>{const r=new Float32Array(i);for(const i in e)e.hasOwnProperty(i)&&(r[e[i]]=t[i]||0);return r}}class Mi{constructor(t={}){this.options={inputSize:0,outputSize:0,binaryThresh:.5},this.trainOpts={activation:"sigmoid",iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,leakyReluAlpha:.01,learningRate:.3,momentum:.1,callbackPeriod:10,timeout:1/0,beta1:.9,beta2:.999,epsilon:1e-8},this.sizes=[],this.outputLayer=-1,this.biases=[],this.weights=[],this.outputs=[],this.deltas=[],this.changes=[],this.errors=[],this.errorCheckInterval=1,this.inputLookup=null,this.inputLookupLength=0,this.outputLookup=null,this.outputLookupLength=0,this._formatInput=null,this._formatOutput=null,this.runInput=(t=>(this.setActivation(),this.runInput(t))),this.calculateDeltas=(t=>(this.setActivation(),this.calculateDeltas(t))),this.biasChangesLow=[],this.biasChangesHigh=[],this.changesLow=[],this.changesHigh=[],this.iterations=0,this.options={...this.options,...t},this.updateTrainingOptions(t);const{inputSize:e,hiddenLayers:i,outputSize:r}=this.options;e&&r&&(this.sizes=[e].concat(null!=i?i:[]).concat([r]))}initialize(){if(!this.sizes.length)throw new Error("Sizes must be set before initializing");this.outputLayer=this.sizes.length-1,this.biases=new Array(this.outputLayer),this.weights=new Array(this.outputLayer),this.outputs=new Array(this.outputLayer),this.deltas=new Array(this.outputLayer),this.changes=new Array(this.outputLayer),this.errors=new Array(this.outputLayer);for(let t=0;t<=this.outputLayer;t++){const e=this.sizes[t];if(this.deltas[t]=I(e),this.errors[t]=I(e),this.outputs[t]=I(e),t>0){this.biases[t]=mt(e),this.weights[t]=new Array(e),this.changes[t]=new Array(e);for(let i=0;i<e;i++){const e=this.sizes[t-1];this.weights[t][i]=mt(e),this.changes[t][i]=I(e)}}}this.setActivation(),"adam"===this.trainOpts.praxis&&this._setupAdam()}setActivation(t){const e=null!=t?t:this.trainOpts.activation;switch(e){case"sigmoid":this.runInput=this._runInputSigmoid,this.calculateDeltas=this._calculateDeltasSigmoid;break;case"relu":this.runInput=this._runInputRelu,this.calculateDeltas=this._calculateDeltasRelu;break;case"leaky-relu":this.runInput=this._runInputLeakyRelu,this.calculateDeltas=this._calculateDeltasLeakyRelu;break;case"tanh":this.runInput=this._runInputTanh,this.calculateDeltas=this._calculateDeltasTanh;break;default:throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}}get isRunnable(){return this.sizes.length>0}run(t){if(!this.isRunnable)throw new Error("network not runnable");let e;if((e=this.inputLookup?H.toArray(this.inputLookup,t,this.inputLookupLength):t).length!==this.sizes[0])throw new Error(`input is not in correct length of ${this.sizes[0]}`);const i=this.runInput(e).slice(0);return this.outputLookup?H.toObject(this.outputLookup,i):i}_runInputSigmoid(t){this.outputs[0]=t;let e=null;for(let i=1;i<=this.outputLayer;i++){const r=this.sizes[i],n=this.weights[i],s=this.biases[i],o=this.outputs[i];for(let e=0;e<r;e++){const i=n[e];let r=s[e];for(let e=0;e<i.length;e++)r+=i[e]*t[e];o[e]=1/(1+Math.exp(-r))}e=t=o}if(!e)throw new Error("output was empty");return e}_runInputRelu(t){this.outputs[0]=t;let e=null;for(let i=1;i<=this.outputLayer;i++){const r=this.sizes[i],n=this.weights[i],s=this.biases[i],o=this.outputs[i];for(let e=0;e<r;e++){const i=n[e];let r=s[e];for(let e=0;e<i.length;e++)r+=i[e]*t[e];o[e]=r<0?0:r}e=t=o}if(!e)throw new Error("output was empty");return e}_runInputLeakyRelu(t){this.outputs[0]=t;const{leakyReluAlpha:e}=this.trainOpts;let i=null;for(let r=1;r<=this.outputLayer;r++){const n=this.sizes[r],s=this.weights[r],o=this.biases[r],h=this.outputs[r];for(let i=0;i<n;i++){const r=s[i];let n=o[i];for(let e=0;e<r.length;e++)n+=r[e]*t[e];h[i]=Math.max(n,e*n)}i=t=h}if(!i)throw new Error("output was empty");return i}_runInputTanh(t){this.outputs[0]=t;let e=null;for(let i=1;i<=this.outputLayer;i++){const r=this.sizes[i],n=this.weights[i],s=this.biases[i],o=this.outputs[i];for(let e=0;e<r;e++){const i=n[e];let r=s[e];for(let e=0;e<i.length;e++)r+=i[e]*t[e];o[e]=Math.tanh(r)}e=t=o}if(!e)throw new Error("output was empty");return e}verifyIsInitialized(t){this.sizes.length||(this.sizes=[],this.sizes.push(t[0].input.length),this.options.hiddenLayers?this.options.hiddenLayers.forEach(t=>{this.sizes.push(t)}):this.sizes.push(Math.max(3,Math.floor(t[0].input.length/2))),this.sizes.push(t[0].output.length),this.initialize())}updateTrainingOptions(t){const e={...this.trainOpts,...t};this.validateTrainingOptions(e),this.trainOpts=e,this.setLogMethod(this.trainOpts.log)}validateTrainingOptions(t){const e={activation:()=>["sigmoid","relu","leaky-relu","tanh"].includes(t.activation),iterations:()=>{const e=t.iterations;return"number"==typeof e&&e>0},errorThresh:()=>{const e=t.errorThresh;return"number"==typeof e&&e>0&&e<1},log:()=>{const e=t.log;return"function"==typeof e||"boolean"==typeof e},logPeriod:()=>{const e=t.logPeriod;return"number"==typeof e&&e>0},leakyReluAlpha:()=>{const e=t.leakyReluAlpha;return"number"==typeof e&&e>0&&e<1},learningRate:()=>{const e=t.learningRate;return"number"==typeof e&&e>0&&e<1},momentum:()=>{const e=t.momentum;return"number"==typeof e&&e>0&&e<1},callback:()=>{const e=t.callback;return"function"==typeof e||void 0===e},callbackPeriod:()=>{const e=t.callbackPeriod;return"number"==typeof e&&e>0},timeout:()=>{const e=t.timeout;return"number"==typeof e&&e>0},praxis:()=>{const e=t.praxis;return!e||"adam"===e},beta1:()=>{const e=t.beta1;return e>0&&e<1},beta2:()=>{const e=t.beta2;return e>0&&e<1},epsilon:()=>{const e=t.epsilon;return e>0&&e<1}};for(const i in e){const r=t;if(!e[i]())throw new Error(`[${i}, ${r[i]}] is out of normal training range, your network will probably not train.`)}}getTrainOptsJSON(){const{activation:t,iterations:e,errorThresh:i,log:r,logPeriod:n,leakyReluAlpha:s,learningRate:o,momentum:h,callbackPeriod:a,timeout:u,praxis:l,beta1:p,beta2:c,epsilon:d}=this.trainOpts;return{activation:t,iterations:e,errorThresh:i,log:"function"==typeof r||"boolean"==typeof r&&r,logPeriod:n,leakyReluAlpha:s,learningRate:o,momentum:h,callbackPeriod:a,timeout:u===1/0?"Infinity":u,praxis:l,beta1:p,beta2:c,epsilon:d}}setLogMethod(t){this.trainOpts.log="function"==typeof t?t:!!t&&this.logTrainingStatus}logTrainingStatus(t){console.log(`iterations: ${t.iterations}, training error: ${t.error}`)}calculateTrainingError(t){let e=0;for(let i=0;i<t.length;++i)e+=this.trainPattern(t[i],!0);return e/t.length}trainPatterns(t){for(let e=0;e<t.length;++e)this.trainPattern(t[e])}trainingTick(t,e,i){const{callback:r,callbackPeriod:n,errorThresh:s,iterations:o,log:h,logPeriod:a}=this.trainOpts;return!(e.iterations>=o||e.error<=s||Date.now()>=i)&&(e.iterations++,h&&e.iterations%a==0?(e.error=this.calculateTrainingError(t),h(e)):e.iterations%this.errorCheckInterval==0?e.error=this.calculateTrainingError(t):this.trainPatterns(t),r&&e.iterations%n==0&&r({iterations:e.iterations,error:e.error}),!0)}prepTraining(t,e={}){this.updateTrainingOptions(e);const i=this.formatData(t),r=Date.now()+this.trainOpts.timeout;return this.verifyIsInitialized(i),{preparedData:i,status:{error:1,iterations:0},endTime:r}}train(t,e={}){const{preparedData:i,status:r,endTime:n}=this.prepTraining(t,e);for(;this.trainingTick(i,r,n););return r}async trainAsync(t,e={}){const{preparedData:i,status:r,endTime:n}=this.prepTraining(t,e);return await new Promise((t,e)=>{try{const s=new mi.Thaw(new Array(this.trainOpts.iterations),{delay:!0,each:()=>this.trainingTick(i,r,n)||s.stop(),done:()=>t(r)});s.tick()}catch(t){e(t)}})}trainPattern(t,e){return this.runInput(t.input),this.calculateDeltas(t.output),this.adjustWeights(),e?Ei(this.errors[this.outputLayer]):null}_calculateDeltasSigmoid(t){for(let e=this.outputLayer;e>=0;e--){const i=this.sizes[e],r=this.outputs[e],n=this.errors[e],s=this.deltas[e],o=this.weights[e+1];for(let h=0;h<i;h++){const i=r[h];let a=0;if(e===this.outputLayer)a=t[h]-i;else{const t=this.deltas[e+1];for(let e=0;e<t.length;e++)a+=t[e]*o[e][h]}n[h]=a,s[h]=a*i*(1-i)}}}_calculateDeltasRelu(t){for(let e=this.outputLayer;e>=0;e--){const i=this.sizes[e],r=this.outputs[e],n=this.weights[e+1],s=this.deltas[e+1],o=this.errors[e],h=this.deltas[e];for(let a=0;a<i;a++){const i=r[a];let u=0;if(e===this.outputLayer)u=t[a]-i;else for(let t=0;t<s.length;t++)u+=s[t]*n[t][a];o[a]=u,h[a]=i>0?u:0}}}_calculateDeltasLeakyRelu(t){const e=this.trainOpts.leakyReluAlpha;for(let i=this.outputLayer;i>=0;i--){const r=this.sizes[i],n=this.outputs[i],s=this.deltas[i+1],o=this.weights[i+1],h=this.errors[i],a=this.deltas[i];for(let u=0;u<r;u++){const r=n[u];let l=0;if(i===this.outputLayer)l=t[u]-r;else for(let t=0;t<s.length;t++)l+=s[t]*o[t][u];h[u]=l,a[u]=r>0?l:e*l}}}_calculateDeltasTanh(t){for(let e=this.outputLayer;e>=0;e--){const i=this.sizes[e],r=this.outputs[e],n=this.deltas[e+1],s=this.weights[e+1],o=this.errors[e],h=this.deltas[e];for(let a=0;a<i;a++){const i=r[a];let u=0;if(e===this.outputLayer)u=t[a]-i;else for(let t=0;t<n.length;t++)u+=n[t]*s[t][a];o[a]=u,h[a]=(1-i*i)*u}}}adjustWeights(){const{learningRate:t,momentum:e}=this.trainOpts;for(let i=1;i<=this.outputLayer;i++){const r=this.outputs[i-1],n=this.sizes[i],s=this.deltas[i],o=this.changes[i],h=this.weights[i],a=this.biases[i];for(let i=0;i<n;i++){const n=s[i];for(let s=0;s<r.length;s++){let a=o[i][s];a=t*n*r[s]+e*a,o[i][s]=a,h[i][s]+=a}a[i]+=t*n}}}_setupAdam(){this.biasChangesLow=[],this.biasChangesHigh=[],this.changesLow=[],this.changesHigh=[],this.iterations=0;for(let t=0;t<=this.outputLayer;t++){const e=this.sizes[t];if(t>0){this.biasChangesLow[t]=I(e),this.biasChangesHigh[t]=I(e),this.changesLow[t]=new Array(e),this.changesHigh[t]=new Array(e);for(let i=0;i<e;i++){const e=this.sizes[t-1];this.changesLow[t][i]=I(e),this.changesHigh[t][i]=I(e)}}}this.adjustWeights=this._adjustWeightsAdam}_adjustWeightsAdam(){this.iterations++;const{iterations:t}=this,{beta1:e,beta2:i,epsilon:r,learningRate:n}=this.trainOpts;for(let s=1;s<=this.outputLayer;s++){const o=this.outputs[s-1],h=this.sizes[s],a=this.deltas[s],u=this.changesLow[s],l=this.changesHigh[s],p=this.weights[s],c=this.biases[s],d=this.biasChangesLow[s],g=this.biasChangesHigh[s];for(let s=0;s<h;s++){const h=a[s];for(let a=0;a<o.length;a++){const c=h*o[a],d=u[s][a]*e+(1-e)*c,g=l[s][a]*i+(1-i)*c*c,f=d/(1-Math.pow(e,t)),w=g/(1-Math.pow(i,t));u[s][a]=d,l[s][a]=g,p[s][a]+=n*f/(Math.sqrt(w)+r)}const f=a[s],w=d[s]*e+(1-e)*f,y=g[s]*i+(1-i)*f*f,m=d[s]/(1-Math.pow(e,t)),L=g[s]/(1-Math.pow(i,t));d[s]=w,g[s]=y,c[s]+=n*m/(Math.sqrt(L)+r)}}}formatData(t){if(!Array.isArray(t[0].input))if(this.inputLookup)this.inputLookupLength=Object.keys(this.inputLookup).length;else{const e=new pi(t,"input");this.inputLookup=e.table,this.inputLookupLength=e.length}if(!Array.isArray(t[0].output))if(this.outputLookup)this.outputLookupLength=Object.keys(this.outputLookup).length;else{const e=new pi(t,"output");this.outputLookup=e.table,this.outputLookupLength=e.length}if(this._formatInput||(this._formatInput=$i(t[0].input,this.inputLookup)),this._formatOutput||(this._formatOutput=$i(t[0].output,this.outputLookup)),this._formatInput&&this._formatOutput){const e=[];for(let i=0;i<t.length;i++)e.push({input:this._formatInput(t[i].input),output:this._formatOutput(t[i].output)});return e}if(this._formatInput){const e=[];for(let i=0;i<t.length;i++)e.push({input:this._formatInput(t[i].input),output:t[i].output});return e}if(this._formatOutput){const e=[];for(let i=0;i<t.length;i++)e.push({input:t[i].input,output:this._formatOutput(t[i].output)});return e}return t}addFormat(t){var e,i;Array.isArray(t.input)&&"number"==typeof t.input[0]||(this.inputLookup=H.addKeys(t.input,null!==(e=this.inputLookup)&&void 0!==e?e:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length)),Array.isArray(t.output)&&"number"==typeof t.output[0]||(this.outputLookup=H.addKeys(t.output,null!==(i=this.outputLookup)&&void 0!==i?i:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length))}test(t){const{preparedData:e}=this.prepTraining(t),i=[];let r=0;if(1===e[0].output.length){let t=0,n=0,s=0,o=0;for(let h=0;h<e.length;h++){const a=this.runInput(e[h].input),u=e[h].output,l=a[0]>this.options.binaryThresh?1:0,p=u[0];if(l!==p){const t=e[h];i.push({input:t.input,output:t.output,actual:l,expected:p})}0===l&&0===p?o++:1===l&&1===p?s++:0===l&&1===p?n++:1===l&&0===p&&t++,r+=Ei(a.map((t,e)=>u[e]-t))}return{error:r/e.length,misclasses:i,total:e.length,trueNeg:o,truePos:s,falseNeg:n,falsePos:t,precision:s>0?s/(s+t):0,recall:s>0?s/(s+n):0,accuracy:(o+s)/e.length}}for(let t=0;t<e.length;t++){const n=this.runInput(e[t].input),s=e[t].output,o=n.indexOf(zi(n)),h=s.indexOf(zi(s));if(o!==h){const r=e[t];i.push({input:r.input,output:r.output,actual:o,expected:h})}r+=Ei(n.map((t,e)=>s[e]-t))}return{error:r/e.length,misclasses:i,total:e.length}}toJSON(){var t,e;this.isRunnable||this.initialize();const i=this.weights.map(t=>t.map(t=>Array.from(t))),r=this.biases.map(t=>Array.from(t)),n=[],s=this.sizes.length-1;for(let o=0;o<=s;o++)n.push({weights:null!==(t=i[o])&&void 0!==t?t:[],biases:null!==(e=r[o])&&void 0!==e?e:[]});return{type:"NeuralNetwork",sizes:[...this.sizes],layers:n,inputLookup:this.inputLookup?{...this.inputLookup}:null,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup?{...this.outputLookup}:null,outputLookupLength:this.outputLookupLength,options:{...this.options},trainOpts:this.getTrainOptsJSON()}}fromJSON(t){if(this.options={inputSize:0,outputSize:0,binaryThresh:.5,...t.options},t.hasOwnProperty("trainOpts")){const e={...t.trainOpts,timeout:"Infinity"===t.trainOpts.timeout?1/0:t.trainOpts.timeout};this.updateTrainingOptions(e)}this.sizes=t.sizes,this.initialize(),this.inputLookup=t.inputLookup?{...t.inputLookup}:null,this.inputLookupLength=t.inputLookupLength,this.outputLookup=t.outputLookup?{...t.outputLookup}:null,this.outputLookupLength=t.outputLookupLength;const e=t.layers,i=this.weights.map((t,i)=>e[i].weights.map(t=>Float32Array.from(t))),r=this.biases.map((t,i)=>Float32Array.from(e[i].biases));for(let t=0;t<=this.outputLayer;t++)this.weights[t]=i[t]||[],this.biases[t]=r[t]||[];return this}toFunction(t){const{activation:e,leakyReluAlpha:i}=this.trainOpts;let r=!1;const n=(t,s)=>{if(0===t)return`(input[${s}]||0)`;const o=this.weights[t][s],h=this.biases[t][s];if(!o)throw new Error(`weights at layerIndex ${t} & nodeIndex ${s} not found`);if(!h)throw new Error(`bias as layerIndex ${t} & nodeIndex ${s} not found`);const a=[];o.forEach((e,i)=>{e<0?a.push(`${e}*${n(t-1,i)}`):a.push(`+${e}*${n(t-1,i)}`)});const u=`(${h.toString()}${a.join("")})`;switch(e){case"sigmoid":return`1/(1+1/Math.exp(${u}))`;case"relu":return r=!0,`((v=${u})<0?0:v)`;case"leaky-relu":return r=!0,`Math.max((v=${u}),${i}*v)`;case"tanh":return`Math.tanh(${u})`;default:throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}};function s(t){if(t.find(t=>t.includes('"')))throw new Error("key contains '\"', which is not compatible")}const o=[];let h,a="";if(this.inputLookup){s(Object.keys(this.inputLookup)),a=`input = new Float32Array([${Object.keys(this.inputLookup).map(t=>`input["${t}"]`).join(",")}]);`}if(this.sizes.length<1)throw new Error("No layers");for(let t=0;t<this.sizes[this.outputLayer];t++)o.push(n(this.outputLayer,t));if(this.outputLookup){const t=Object.keys(this.outputLookup);s(t),h=`{${t.map((t,e)=>`"${t}":${o[e]}`).join(",")}}`}else h=`[${o.join(",")}]`;const u=`${a}${r?"var v;":""}return ${h};`;return new Function("input",t?t(u):u)}}function Pi(t,e,i){let r=e[this.thread.x];for(let e=0;e<this.constants.size;e++)r+=t[this.thread.x][e]*i[e];return 1/(1+Math.exp(-r))}function _i(t,e,i){let r=e[this.thread.x];for(let e=0;e<this.constants.size;e++)r+=t[this.thread.x][e]*i[e];return r<0?0:r}function Ki(t,e,i){let r=e[this.thread.x];for(let e=0;e<this.constants.size;e++)r+=t[this.thread.x][e]*i[e];return r<0?0:.01*r}function Ti(t,e,i){let r=e[this.thread.x];for(let e=0;e<this.constants.size;e++)r+=t[this.thread.x][e]*i[e];return Math.tanh(r)}function Di(t,e){return e-t}function ji(t,e){return t*e*(1-e)}function Fi(t,e){return e>0?t:0}function Ni(t,e){return e>0?t:.01*t}function Ci(t,e){return(1-e*e)*t}function Ri(t,e,i,r){let n=0;for(let s=0;s<e;s++)n+=r[s]*i[s][t];return n}function Hi(t,e,i,r,n){return t*r*n+e*i}function qi(t,e){return t+e}function Wi(t,e){return t[this.thread.x]+e[this.thread.x]*this.constants.learningRate}function Xi(t){let e=0;for(let i=0;i<this.constants.size;i++)e+=t[i]**2;return e/this.constants.size}class Yi extends Mi{constructor(t={}){super(t),this.texturizeInputData=(()=>{throw new Error("not yet setup")}),this.forwardPropagate=[],this.backwardPropagate=[],this.changesPropagate=[],this.biasesPropagate=[],this.getMSE=(()=>{throw new Error("not yet setup")}),this._addMSE=(()=>{throw new Error("not yet setup")}),this._divideMSESum=(()=>{throw new Error("not yet setup")}),this.outputs=[],this.deltas=[],this.errors=[],this.weights=[],this.changes=[],this.biases=[],this.runInput=(t=>{let e;this.outputs[0]=t;for(let i=1;i<=this.outputLayer;i++)b(this.outputs[i]),this.outputs[i]=this.forwardPropagate[i](this.weights[i],this.biases[i],t),e=t=this.outputs[i];return e}),this.calculateDeltas=(t=>{for(let e=this.outputLayer;e>0;e--){let i;b(this.deltas[e]),b(this.errors[e]),i=e===this.outputLayer?this.backwardPropagate[e](this.outputs[e],t):this.backwardPropagate[e](this.weights[e+1],this.outputs[e],this.deltas[e+1]),this.deltas[e]=i.result,this.errors[e]=i.error}}),this.errorCheckInterval=100,this.gpu=new e.GPU({mode:t.mode})}initialize(){super.initialize(),this.buildRunInput(),this.buildCalculateDeltas(),this.buildGetChanges(),this.buildChangeBiases(),this.buildGetMSE()}setActivation(){}trainPattern(t,e){return this.runInput(t.input),this.calculateDeltas(t.output),this.adjustWeights(),e?this.getMSE(this.errors[this.outputLayer]):null}calculateTrainingError(t){let i=new Float32Array([0]);for(let e=0;e<t.length;++e){const r=i,n=this.trainPattern(t[e],!0);i=this._addMSE(i,n),b(n),b(r)}const r=this._divideMSESum(t.length,i);return b(i),(r instanceof e.Texture?r.toArray():r)[0]}adjustWeights(){this.getChanges(),this.changeBiases()}buildRunInput(){let t=null;switch(this.trainOpts.activation){case"sigmoid":t=Pi;break;case"relu":t=_i;break;case"leaky-relu":t=Ki;break;case"tanh":t=Ti;break;default:throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}for(let e=1;e<=this.outputLayer;e++)this.forwardPropagate[e]=this.gpu.createKernel(t,{output:[this.sizes[e]],pipeline:!0,constants:{size:this.sizes[e-1]},immutable:!0});this.texturizeInputData=this.gpu.createKernel(function(t){return t[this.thread.x]},{output:[this.sizes[1]],pipeline:!0,immutable:!0})}buildCalculateDeltas(){let t;switch(this.trainOpts.activation){case"sigmoid":t=ji;break;case"relu":t=Fi;break;case"leaky-relu":t=Ni;break;case"tanh":t=Ci;break;default:throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)}t=e.alias(e.utils.getMinifySafeName(()=>t),t),this.gpu.addFunction(t);for(let e=this.outputLayer;e>0;e--)e===this.outputLayer?this.backwardPropagate[this.outputLayer]=this.gpu.createKernelMap({error:Di},function(e,i){const r=e[this.thread.x],n=i[this.thread.x];return t(Di(r,n),r)},{output:[this.sizes[this.outputLayer]],pipeline:!0,immutable:!0}):this.backwardPropagate[e]=this.gpu.createKernelMap({error:Ri},function(e,i,r){const n=i[this.thread.x];return t(Ri(this.thread.x,this.constants.size,e,r),n)},{output:[this.sizes[e]],pipeline:!0,constants:{size:this.sizes[e+1]},immutable:!0})}buildGetChanges(){for(let t=1;t<=this.outputLayer;t++)this.changesPropagate[t]=this.gpu.createKernelMap({weights:qi,changes:Hi},function(t,e,i,r){return qi(Hi(this.constants.learningRate,this.constants.momentum,r[this.thread.y][this.thread.x],e[this.thread.y],t[this.thread.x]),i[this.thread.y][this.thread.x])},{output:[this.sizes[t-1],this.sizes[t]],pipeline:!0,constants:{size:this.sizes[t-1],learningRate:this.trainOpts.learningRate,momentum:this.trainOpts.momentum},immutable:!0})}getChanges(){for(let t=1;t<=this.outputLayer;t++){const e=this.weights[t],i=this.changes[t],r=this.changesPropagate[t](this.outputs[t-1],this.deltas[t],e,i);b(e),b(i),this.weights[t]=r.weights,this.changes[t]=r.changes,b(r.result)}}buildChangeBiases(){for(let t=1;t<=this.outputLayer;t++)this.biasesPropagate[t]=this.gpu.createKernel(Wi,{output:[this.sizes[t]],pipeline:!0,constants:{learningRate:this.trainOpts.learningRate},immutable:!0})}changeBiases(){for(let t=1;t<=this.outputLayer;t++){const e=this.biases[t];this.biases[t]=this.biasesPropagate[t](e,this.deltas[t]),b(e)}}buildGetMSE(){this.getMSE=this.gpu.createKernel(Xi,{output:[1],constants:{size:this.sizes[this.outputLayer]},pipeline:!0,immutable:!0}),this._addMSE=this.gpu.createKernel(function(t,e){return t[0]+e[0]},{output:[1],pipeline:!0,immutable:!0}),this._divideMSESum=this.gpu.createKernel(function(t,e){const i=e[0];return i>0?i/t:0},{output:[1]})}run(t){if(!this.isRunnable)throw new Error("network not runnable");let i;i=this.inputLookup?H.toArray(this.inputLookup,t,this.inputLookupLength):t;const r=this.runInput(i),n=r instanceof e.Texture?r.toArray():r;return this.outputLookup?H.toObject(this.outputLookup,n):n}prepTraining(t,e={}){this.updateTrainingOptions(e);const i=this.formatData(t),r=Date.now()+this.trainOpts.timeout;this.verifyIsInitialized(i);const n=this.gpu.createKernel(function(t){return t[this.thread.x]},{output:[i[0].output.length],pipeline:!0,immutable:!0});return{preparedData:i.map(t=>({input:this.texturizeInputData(t.input),output:n(t.output)})),status:{error:1,iterations:0},endTime:r}}toFunction(){throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)}toJSON(){var t,i;null===this.sizes&&this.initialize();const r=this.weights.map(t=>(t instanceof e.Texture?t.toArray():t).map(t=>Array.from(t))),n=this.biases.map(t=>Array.from(t instanceof e.Texture?t.toArray():t)),s=[];for(let e=0;e<=this.outputLayer;e++)s.push({weights:null!==(t=r[e])&&void 0!==t?t:[],biases:null!==(i=n[e])&&void 0!==i?i:[]});return{type:"NeuralNetworkGPU",sizes:[...this.sizes],layers:s,inputLookup:this.inputLookup?{...this.inputLookup}:null,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup?{...this.outputLookup}:null,outputLookupLength:this.outputLookupLength,options:{...this.options},trainOpts:this.getTrainOptsJSON()}}}class Ji extends P{constructor(){super(...arguments),this.settings={},this.layer=null}setLayer(t){this.layer=t}get width(){if(!this.layer)throw new Error("layer not set");return this.layer.width}set width(t){throw new Error(`${this.constructor.name}-width is not yet implemented`)}get height(){if(!this.layer)throw new Error("layer not set");return this.layer.height}set height(t){throw new Error(`${this.constructor.name}-height is not yet implemented`)}get deltas(){if(!this.layer)throw new Error("layer not set");return this.layer.deltas}set deltas(t){if(!this.layer)throw new Error("layer not set");b(this.layer.deltas),this.layer.deltas=t}get weights(){if(!this.layer)throw new Error("layer not set");return this.layer.weights}set weights(t){if(!this.layer)throw new Error("layer not set");b(this.layer.weights),this.layer.weights=t}predict(){}compare(){}learn(){throw new Error("no longer using")}setupKernels(){}reuseKernels(){}}class Bi extends gi{constructor(t={}){super(t),this.trainOpts={},this._outputConnection=null,this._layerSets=[],this._hiddenLayerOutputIndices=[],this._model=null}_connectLayers(){if(!this.options.inputLayer)throw new Error("inputLayer not found");if(!this.options.outputLayer)throw new Error("outputLayer not found");const t=this.options.inputLayer(),e=this._connectHiddenLayers(t);return{inputLayer:t,hiddenLayers:e,outputLayer:this.options.outputLayer(e[e.length-1],-1)}}_connectLayersDeep(){const t=[],e=this._layerSets[this._layerSets.length-1];let i=0;function r(i){const r=e.indexOf(i);if(r<0)throw new Error("unable to find layer");return t[r]}function n(t){return{...t.settings,weights:null,deltas:null,praxis:null}}for(let s=0;s<e.length;s++){const o=e[s];let h;if(o instanceof $)h=new o.constructor(r(o.inputLayer),n(o));else if(o instanceof C)h=new o.constructor(n(o));else if(o instanceof M)h=new o.constructor(n(o.inputLayer),r(o.inputLayer));else if(o instanceof P){const t=e[this._hiddenLayerOutputIndices[i++]];if(o instanceof Ji)throw new Error("unfinished");if(o instanceof De)h=new De(t);else{if(!(o instanceof je))throw new Error(`hidden layer ${o.constructor.name} extends unknown hidden layer`);h=new De(t)}}else if(o instanceof N||o instanceof R)h=o;else if(o instanceof _)h=new o.constructor(r(o.inputLayer),n(o.inputLayer));else if(o instanceof K)h=new o.constructor(r(o.inputLayer1),r(o.inputLayer2),n(o));else{if(!(o instanceof j))throw new Error(`hidden layer ${o.constructor.name} extends unknown hidden layer`);h=new o.constructor(n(o),r(o.inputLayer))}t.push(h)}return t}_connectHiddenLayers(t){const e=[];if(!this.options.hiddenLayers)throw new Error("hiddenLayers not defined");for(let i=0;i<this.options.hiddenLayers.length;i++){const r=new je,n=this.options.hiddenLayers[i](t,r,i);t=n,e.push(n)}return e}initialize(){let t;if(this._outputConnection=new Ji,this.options.layers)t=this._connectOptionsLayers();else{const{inputLayer:e,hiddenLayers:i,outputLayer:r}=this._connectLayers();t=ut([e,...i,r]),this._hiddenLayerOutputIndices=i.map(e=>t.indexOf(e)),this._inputLayer=e,this._hiddenLayers=i,this._outputLayer=r}this.layers=t,this._layerSets=[t],this._model=t.filter(t=>t instanceof R||t instanceof N),this.initializeLayers(t)}initializeDeep(){const t=this._connectLayersDeep();for(let e=0;e<t.length;e++){const i=t[e];i.setupKernels(!0),i.reuseKernels(this._layerSets[0][e])}this._layerSets.push(t)}run(t){for(;this._layerSets.length<=t.length;)this.initializeDeep();const i=this.runInputs(t);return i instanceof e.Texture?i.toArray():i}runInput(t){throw new Error("use .runInputs()")}runInputs(t){for(;this._layerSets.length<t.length;)this.initializeDeep();const e=t.length-1;for(let i=0;i<=e;i++){const e=this._layerSets[i];e[0].predict(t[i]);for(let t=1;t<e.length;t++)e[t].predict()}const i=this._layerSets[e],r=i[i.length-1].weights;return this.end(),r}train(t,e={}){const{preparedData:i,status:r,endTime:n}=this._prepTraining(t,e);let s=!0;const o=()=>this._calculateTrainingError(i),h=()=>this._trainPatterns(i);for(;s;)s=this._trainingTick(r,n,o,h);return r}end(){const t=this._layerSets.length-1,e=this._layerSets[t];e[0].predict([new Float32Array([0])]);for(let t=1;t<e.length;t++)e[t].predict()}transferData(t){return t}_prepTraining(t,e){this._updateTrainingOptions(e);const i=this.trainOpts.timeout?Date.now()+this.trainOpts.timeout:0;return this.verifyIsInitialized(),{preparedData:this.transferData(t),status:{error:1,iterations:0},endTime:i}}_calculateTrainingError(t){if(!this.meanSquaredError)throw new Error("this.meanSquaredError not setup");let i=new Float32Array(1);for(let e=0;e<t.length;++e){const r=i,n=this._trainPattern(t[e],!0);i=this.meanSquaredError.add(i,n),b(n),b(r)}const r=this.meanSquaredError.divide(t.length,i);if(b(i),r instanceof e.Texture){return r.toArray()[0]}return r[0]}formatData(t){return t}_calculateDeltas(t){const e=this._layerSets[this._layerSets.length-1];for(let t=e.length-2;t>=0;t--)e[t].compare();for(let e=t.length-2;e>=0;e--){const i=this._layerSets[e];i[i.length-1].compare(t[e+1]);for(let t=i.length-2;t>=0;t--)i[t].compare()}}adjustWeights(){var t;const e=this._model;for(let i=0;i<e.length;i++)e[i].learn(null!==(t=this.options.learningRate)&&void 0!==t?t:0)}_trainPatterns(t){for(let e=0;e<t.length;++e)this._trainPattern(t[e],!1)}_trainPattern(t,e){if(this.runInputs(t),this._calculateDeltas(t),this.adjustWeights(),e){if(!this.meanSquaredError)throw new Error("this.meanSquaredError not setup");let e=new Float32Array(1);for(let i=0,r=t.length-2;i<=r;i++){const t=this._layerSets[i],r=t[t.length-1],n=e;e=this.meanSquaredError.addAbsolute(n,r.errors),b(n)}return x(this.meanSquaredError.divide(t.length,e))}return null}}class Gi{constructor(t,e){this.rows=0,this.columns=0,t&&(this.rows=t),e&&(this.columns=e),this.weights=I(this.rows*this.columns),this.deltas=I(this.rows*this.columns)}getWeight(t,e){const i=this.columns*t+e;if(i<0||i>=this.weights.length)throw new Error("get accessor is skewed");return this.weights[i]}setWeight(t,e,i){const r=this.columns*t+e;if(r<0||r>=this.weights.length)throw new Error("set accessor is skewed");return this.weights[r]=i,this}getDelta(t,e){const i=this.columns*t+e;if(i<0||i>=this.deltas.length)throw new Error("get accessor is skewed");return this.deltas[i]}setDelta(t,e,i){const r=this.columns*t+e;if(r<0||r>=this.weights.length)throw new Error("set accessor is skewed");return this.deltas[r]=i,this}toJSON(){return{rows:this.rows,columns:this.columns,weights:Array.from(this.weights.slice(0))}}static fromJSON(t){const e=new Gi(t.rows,t.columns);for(let i=0,r=t.rows*t.columns;i<r;i++)e.weights[i]=t.weights[i];return e}static fromArray(t){const e=new Gi(t.length,t[0].length);return e.fromArray(t),e}deltasToArray(){return this.toArray("deltas")}weightsToArray(){return this.toArray("weights")}toArray(t="weights"){const e=new Array(this.rows);return this.iterate({row:t=>{e[t]=new Array(this.columns)},column:(i,r)=>{"weights"===t?e[i][r]=this.getWeight(i,r):"deltas"===t&&(e[i][r]=this.getDelta(i,r))}}),e}fromArray(t,e="weights"){if(t.length!==this.rows)throw new Error("rows do not match");if(t[0].length!==this.columns)throw new Error("columns do not match");return this.iterate({column:(i,r)=>{const n=t[i][r];if("number"!=typeof n)throw new Error("value not number");"weights"===e?this.setWeight(i,r,n):"deltas"===e&&this.setDelta(i,r,n)}}),this}iterate(t){const e=this.rows,i=this.columns;for(let r=0;r<e;r++){t.row&&t.row(r);for(let e=0;e<i;e++)t.column&&t.column(r,e)}return this}}class Vi extends Gi{constructor(t,e,i){super(t,e),this.std=i;for(let t=0,e=this.weights.length;t<e;t++)this.weights[t]=ft(-i,i)}}class Ui{constructor(t,e=0){this.values=t,this.indexTable={},this.characterTable={},this.characters=[],this.specialIndexes=[],this.isSetup=!1,void 0!==t&&this.setup(t,e)}setup(t,e=0){if(this.isSetup)throw new Error("DataFormatter is already setup");this.values=t,this.buildCharactersFromIterable(t),this.buildTables(e),t[0].input&&this.addInputOutput(),this.addUnrecognized(),this.isSetup=!0}buildCharactersFromIterable(t){const e={};for(let i=0,r=t.length;i<r;i++){const r=t[i];if(r.hasOwnProperty("length")){const t=r;for(let i=0,r=t.length;i<r;i++){const r=t[i];e.hasOwnProperty(r)||(e[r]=!0,this.characters.push(r))}}else if("number"==typeof r){if(e.hasOwnProperty(r))continue;e[r]=!0,this.characters.push(r)}else if("boolean"==typeof r){const t=r.toString();if(e.hasOwnProperty(t))continue;e[t]=!0,this.characters.push(t)}else if(Array.isArray(r)&&"string"==typeof r[0])for(let t=0;t<r.length;t++){const i=r[t];e.hasOwnProperty(i)||(e[i]=!0,this.characters.push(i))}else if(!Array.isArray(r)||"number"!=typeof r[0]&&"boolean"!=typeof r[0]){if(!r.hasOwnProperty("input")||!r.hasOwnProperty("output"))throw new Error("Unhandled value");{const{input:t,output:i}=r;Array.isArray(t)?this.addCharacters(t,e):this.addCharacters(t.toString(),e),Array.isArray(i)?this.addCharacters(i,e):this.addCharacters(i.toString(),e)}}else for(let t=0;t<r.length;t++){const n=r[t].toString();e.hasOwnProperty(i)||(e[n]=!0,this.characters.push(n))}}}addCharacters(t,e){for(let i=0;i<t.length;i++){const r=t[i].toString();e.hasOwnProperty(r)||(e[r]=!0,this.characters.push(r))}}buildTables(t){const e=this.characters.length;for(let i=0;i<e;i++){const e=this.characters[i];i>=t&&(this.indexTable[e]=i,this.characterTable[i]=e)}}toIndexes(t,e=0){const i=[],{indexTable:r}=this;switch(typeof t){case"number":case"boolean":t=t.toString()}for(let n=0,s=t.length;n<s;n++){const s=t[n].toString();let o=r[s];if(void 0===o){if(!r.unrecognized)throw new Error(`unrecognized character "${s}"`);o=r.unrecognized}o<e||i.push(o)}return i}toIndexesInputOutput(t,e,i=0){const r=this.toIndexesValue(t,i,!0);return void 0===e?r:r.concat(this.toIndexesValue(e,i,!1))}toIndexesValue(t,e,i){if("string"==typeof t)t=t.split("");else if("number"==typeof t||"boolean"==typeof t)t=t.toString().split("");else{if(!Array.isArray(t)||"number"!=typeof t[0]&&"boolean"!=typeof t[0]&&"string"!=typeof t[0])throw new Error("unrecognized value");t=t.map(t=>t.toString())}return i&&(t=t.concat(["stop-input","start-output"])),this.toIndexes(t,e)}toCharacters(t,e=0){const i=[],{indexTable:r,characterTable:n}=this;for(let s=0,o=t.length;s<o;s++){const o=t[s];if(o<e)continue;let h=n[o];if(void 0===h){if(!r.unrecognized)throw new Error(`unrecognized index "${o}"`);h=n[r.unrecognized]}else null!==h&&i.push(h.toString())}return i}toString(t,e){return this.toCharacters(t,e).join("")}addInputOutput(){this.addSpecial("stop-input"),this.addSpecial("start-output")}addUnrecognized(){this.addSpecial("unrecognized")}static fromAllPrintable(t,e=["\n"]){for(let t=32;t<=126;t++)e.push(String.fromCharCode(t));return new Ui(e,t)}static fromAllPrintableInputOutput(t,e=["\n"]){const i=Ui.fromAllPrintable(t,e);return i.addInputOutput(),i.addUnrecognized(),i}static fromStringInputOutput(t,e){const i=Array.from(new Set(t)).join(""),r=new Ui(i.split(""),e);return r.addInputOutput(),r.addUnrecognized(),r.isSetup=!0,r}static fromArrayInputOutput(t,e){const i=[];for(let e=0;e<t.length;e++){const r=t[e];i.push(Zi(r.input),Zi(r.output))}const r=Array.isArray(i)?i.flat():i,n=new Ui(Array.from(new Set(r)),e);return n.addInputOutput(),n.addUnrecognized(),n.isSetup=!0,n}static fromString(t,e=0){const i=Array.from(new Set(t)).join("");return new Ui(i.split(""),e)}toJSON(){return{indexTable:this.indexTable,characterTable:this.characterTable,values:this.values,characters:this.characters,specialIndexes:this.specialIndexes}}static fromJSON(t){const e=new Ui;return e.indexTable=t.indexTable,e.characterTable=t.characterTable,e.values=t.values,e.characters=t.characters,e.specialIndexes=t.specialIndexes,e}addSpecial(t,e=null){const i=this.indexTable[t]=this.characters.length;this.characterTable[i]=e,this.specialIndexes.push(this.characters.length),this.characters.push(t)}toFunctionString(){return`\nvar characterTable = ${JSON.stringify(this.characterTable)};\nvar indexTable = ${JSON.stringify(this.indexTable)};\nvar characters = ${JSON.stringify(this.characters)};\nvar dataFormatter = {\n  toIndexes: function ${this.toIndexes.toString()},\n  toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},\n  toCharacters: function ${this.toCharacters.toString()},\n  toIndexesValue: function ${this.toIndexesValue.toString()},\n};`}formatDataIn(t,e){var i;return void 0===t?[]:Array.isArray(t)&&"number"==typeof t[0]?t:(null===(i=this.indexTable)||void 0===i?void 0:i.hasOwnProperty("stop-input"))?this.toIndexesInputOutput(t,e):this.toIndexes(t)}formatDataOut(t,e){return this.toCharacters(e).join("")}format(t){if(!("number"!=typeof t[0]||Array.isArray(t[0])||t[0].hasOwnProperty("input")&&t[0].hasOwnProperty("output")))return t;const e=[];if("string"==typeof t[0]||"number"==typeof t[0]||Array.isArray(t[0]))if(this.isSetup)for(let i=0,r=t.length;i<r;i++)e.push(this.formatDataIn(t[i]));else{this.setup(t);for(let i=0;i<t.length;i++)e.push(this.formatDataIn(Zi(t[i])))}else{if(!t[0].input||!t[0].output)throw new Error("unrecognized data");this.isSetup||this.setup(t);for(let i=0,r=t.length;i<r;i++)e.push(this.formatDataIn(Zi(t[i].input),Zi(t[i].output)))}return e}}function Zi(t){if("string"==typeof t)return t;if("number"==typeof t)return t.toString();if("boolean"==typeof t)return t.toString();if(Array.isArray(t)&&"string"==typeof t[0])return t;if("boolean"==typeof t[0])return t.map(t=>t.toString());if("number"==typeof t[0])return t.map(t=>t.toString());throw new Error("unrecognized value, expected string[], string, number[], number, boolean[], or boolean")}function Qi(t,e,i){for(let r=0;r<e.weights.length;r++)t.weights[r]=e.weights[r]+i.weights[r],t.deltas[r]=0}function tr(t,e,i){for(let r=0;r<t.deltas.length;r++)e.deltas[r]=t.deltas[r],i.deltas[r]=t.deltas[r]}function er(t){for(let e=0;e<t.weights.length;e++)t.weights[e]=1,t.deltas[e]=0}function ir(t,e){t.rows=e.rows,t.columns=e.columns,t.weights=e.weights.slice(0),t.deltas=e.deltas.slice(0);for(let i=0;i<e.weights.length;i++)t.weights[i]=-e.weights[i],t.deltas[i]=0}function rr(t,e,i){const r=e.rows,n=e.columns,s=i.columns;for(let o=0;o<r;o++){const r=n*o,h=s*o;for(let o=0;o<s;o++){let a=0;for(let t=0;t<n;t++){const n=r+t,h=s*t+o;a+=e.weights[n]*i.weights[h],e.deltas[n]=0,i.deltas[h]=0}t.weights[h+o]=a}}}function nr(t,e,i){const r=e.rows,n=e.columns,s=i.columns;for(let o=0;o<r;o++){const r=n*o,h=s*o;for(let o=0;o<s;o++)for(let a=0;a<n;a++){const n=r+a,u=s*a+o,l=t.deltas[h+o];e.deltas[n]+=i.weights[u]*l,i.deltas[u]+=e.weights[n]*l}}}function sr(t,e,i){const{weights:r}=e;for(let n=0;n<r.length;n++)t.weights[n]=e.weights[n]*i.weights[n],t.deltas[n]=0}function or(t,e,i){for(let r=0;r<e.weights.length;r++)e.deltas[r]=i.weights[r]*t.deltas[r],i.deltas[r]=e.weights[r]*t.deltas[r]}function hr(t,e){for(let i=0;i<e.weights.length;i++)t.weights[i]=Math.max(0,e.weights[i]),t.deltas[i]=0}function ar(t,e){for(let i=0;i<t.deltas.length;i++)e.deltas[i]=e.weights[i]>0?t.deltas[i]:0}function ur(t,e,i){const{columns:r}=e,n=r*i;for(let i=0;i<r;i++)t.weights[i]=e.weights[n+i],t.deltas[i]=0}function lr(t,e,i){const{columns:r}=e,n=r*i;for(let i=0;i<r;i++)e.deltas[n+i]=t.deltas[i]}function pr(t,e){for(let i=0;i<e.weights.length;i++)t.weights[i]=1/(1+Math.exp(-e.weights[i])),t.deltas[i]=0}function cr(t,e){for(let i=0;i<t.deltas.length;i++){const r=t.weights[i];e.deltas[i]=r*(1-r)*t.deltas[i]}}function dr(t){const e=new Gi(t.rows,t.columns);let i=-999999;for(let e=0;e<t.weights.length;e++)t.weights[e]>i&&(i=t.weights[e]);let r=0;for(let n=0;n<t.weights.length;n++)e.weights[n]=Math.exp(t.weights[n]-i),r+=e.weights[n];for(let i=0;i<t.weights.length;i++)e.weights[i]/=r;return e}function gr(t,e){for(let i=0;i<e.weights.length;i++)t.weights[i]=Math.tanh(e.weights[i]),t.deltas[i]=0}function fr(t,e){for(let i=0;i<t.deltas.length;i++){const r=t.weights[i];e.deltas[i]=(1-r*r)*t.deltas[i]}}class wr{constructor(){this.states=[],this.inputRow=0}add(t,e){if(t.weights.length!==e.weights.length)throw new Error("misaligned matrices");const i=new Gi(t.rows,t.columns);return this.states.push({name:"add",product:i,left:t,right:e,forwardFn:Qi,backpropagationFn:tr}),i}allOnes(t,e){const i=new Gi(t,e);return this.states.push({name:"allOnes",product:i,left:i,forwardFn:er,backpropagationFn:()=>{}}),i}cloneNegative(t){const e=new Gi(t.rows,t.columns);return this.states.push({name:"cloneNegative",product:e,left:t,forwardFn:ir,backpropagationFn:()=>{}}),e}subtract(t,e){if(t.weights.length!==e.weights.length)throw new Error("misaligned matrices");return this.add(this.add(this.allOnes(t.rows,t.columns),this.cloneNegative(t)),e)}multiply(t,e){if(t.columns!==e.rows)throw new Error("misaligned matrices");const i=new Gi(t.rows,e.columns);return this.states.push({name:"multiply",product:i,left:t,right:e,forwardFn:rr,backpropagationFn:nr}),i}multiplyElement(t,e){if(t.weights.length!==e.weights.length)throw new Error("misaligned matrices");const i=new Gi(t.rows,t.columns);return this.states.push({name:"multiplyElement",product:i,left:t,right:e,forwardFn:sr,backpropagationFn:or}),i}relu(t){const e=new Gi(t.rows,t.columns);return this.states.push({name:"relu",product:e,left:t,forwardFn:hr,backpropagationFn:ar}),e}input(t){return this.states.push({name:"input",product:t,forwardFn:e=>{if(this.inputValue){if(this.inputValue.length!==e.weights.length)throw new Error("this.inputValue is of wrong dimensions");e.weights=t.weights=this.inputValue}},backpropagationFn:()=>{}}),t}inputMatrixToRow(t){const e=this,i=new Gi(t.columns,1);return this.states.push({name:"inputMatrixToRow",product:i,left:t,get right(){return e.inputRow},forwardFn:ur,backpropagationFn:lr}),i}sigmoid(t){const e=new Gi(t.rows,t.columns);return this.states.push({name:"sigmoid",product:e,left:t,forwardFn:pr,backpropagationFn:cr}),e}tanh(t){const e=new Gi(t.rows,t.columns);return this.states.push({name:"tanh",product:e,left:t,forwardFn:gr,backpropagationFn:fr}),e}observe(t){return this.states.push({name:"observe",product:new Gi,forwardFn:()=>{},backpropagationFn:()=>{}}),t}runIndex(t=0){this.inputRow=t;let e=this.states[0];for(let t=0,i=this.states.length;t<i;t++)(e=this.states[t]).hasOwnProperty("forwardFn")&&e.forwardFn(e.product,e.left,e.right);return e.product}runInput(t){this.inputValue=t;let e=this.states[0];for(let t=0,i=this.states.length;t<i;t++)(e=this.states[t]).hasOwnProperty("forwardFn")&&e.forwardFn(e.product,e.left,e.right);return e.product}backpropagate(){let t=this.states.length,e=this.states[0];for(;t-- >0;)(e=this.states[t]).hasOwnProperty("backpropagationFn")&&e.backpropagationFn(e.product,e.left,e.right);return e.product}backpropagateIndex(t=0){this.inputRow=t;let e=this.states.length,i=this.states[0];for(;e-- >0;)(i=this.states[e]).hasOwnProperty("backpropagationFn")&&i.backpropagationFn(i.product,i.left,i.right);return i.product}predictTarget(t,e){let i=0;const r=this.runInput(t);for(let t=0;t<r.weights.length;t++){const n=r.weights[t]-e[t];i+=Math.abs(n),r.deltas[t]=n}return i}predictTargetIndex(t,e){const i=this.runIndex(t),r=i,n=dr(i);return r.deltas=n.weights.slice(0),r.deltas[e]-=1,-Math.log2(n.weights[e])}}function yr(t){const{weights:e}=t;let i=e[0],r=0;for(let t=1;t<e.length;t++){const n=e[t];n<i||(r=t,i=n)}return r}function mr(t){const e=ft(0,1),i=t.weights;let r=0,n=0;for(;;){if((r+=i[n])>e)return n;n++}}const Lr={iterations:2e4,errorThresh:.005,log:!1,logPeriod:10,learningRate:.01,callbackPeriod:10,timeout:1/0},br=()=>({inputSize:20,inputRange:20,hiddenLayers:[20,20],outputSize:20,decayRate:.999,smoothEps:1e-8,regc:1e-6,clipval:5,maxPredictionLength:100,dataFormatter:new Ui});class xr{constructor(t={}){this.options={...br()},this.trainOpts={...Lr},this.stepCache={},this.runs=0,this.ratioClipped=0,this.model=Object.seal({isInitialized:!1,input:new Gi(0,0),hiddenLayers:[],output:new Gi(0,0),equations:[],allMatrices:[],equationConnections:[],outputConnector:new Vi(0,0,.08)}),this.initialLayerInputs=[],this.options={...this.options,...t},this.updateTrainingOptions({...Lr}),t.json&&this.fromJSON(t.json)}initialize(){const{dataFormatter:t}=this.options;(null==t?void 0:t.characters.length)&&(this.options.inputSize=this.options.inputRange=this.options.outputSize=t.characters.length),this.model=this.mapModel()}createHiddenLayers(){const{hiddenLayers:t,inputSize:e}=this.options,i=[];i.push(this.getHiddenLayer(t[0],e));let r=t[0];for(let e=1;e<t.length;e++){const n=t[e];i.push(this.getHiddenLayer(n,r)),r=n}return i}getHiddenLayer(t,e){return{weight:new Vi(t,e,.08),transition:new Vi(t,t,.08),bias:new Gi(t,1)}}getEquation(t,e,i,r){if(!r.weight||!r.transition||!r.bias)throw new Error("hiddenLayer does not have expected properties");const n=t.relu.bind(t),s=t.add.bind(t),o=t.multiply.bind(t);return n(s(s(o(r.weight,e),o(r.transition,i)),r.bias))}createInputMatrix(){const{inputRange:t,inputSize:e}=this.options;if(t<1)throw new Error("this.options.inputRange not an expected number");if(e<1)throw new Error("this.options.inputSize not an expected number");return new Vi(t+1,e,.08)}createOutputMatrices(){const{outputSize:t,hiddenLayers:e}=this.options,i=kr(e);return{outputConnector:new Vi(t+1,i,.08),output:new Gi(t+1,1)}}bindEquation(){const{model:t}=this,{hiddenLayers:e}=this.options,i=new wr,r=[],n=t.equationConnections.length>0?kr(t.equationConnections):this.initialLayerInputs;let s=this.getEquation(i,i.inputMatrixToRow(t.input),n[0],t.hiddenLayers[0]);r.push(s);for(let o=1,h=e.length;o<h;o++){if(!n[o])throw new Error(`Cannot find equation at index ${o}`);s=this.getEquation(i,s,n[o],t.hiddenLayers[o]),r.push(s)}t.equationConnections.push(r),i.add(i.multiply(t.outputConnector,s),t.output),t.equations.push(i)}mapModel(){const t=[];this.initialLayerInputs=this.options.hiddenLayers.map(t=>new Gi(t,1));const e=this.createInputMatrix();t.push(e);const i=this.createHiddenLayers();if(!i.length)throw new Error("net.hiddenLayers not set");for(let e=0,r=i.length;e<r;e++){const r=i[e];for(const e in r)r.hasOwnProperty(e)&&t.push(r[e])}const{output:r,outputConnector:n}=this.createOutputMatrices();return t.push(n),t.push(r),Object.seal({isInitialized:!0,input:e,hiddenLayers:i,output:r,equations:[],allMatrices:t,equationConnections:[],outputConnector:n})}trainInput(t){this.runs++;const{model:e}=this,i=t.length;let r,n=0;for(;e.equations.length<=t.length+1;)this.bindEquation();for(let s=-1,o=t.length;s<o;s++){const o=s+1;r=e.equations[o];const h=-1===s?0:t[s]+1,a=s===i-1?0:t[s+1]+1;n+=r.predictTargetIndex(h,a)}return Math.pow(2,n/(i-1))/100}backpropagate(t){let e=t.length;const{model:i}=this,{equations:r}=i;for(;e>0;)r[e].backpropagateIndex(t[e-1]+1),e--;r[0].backpropagateIndex(0)}adjustWeights(){const{regc:t,clipval:e,decayRate:i,smoothEps:r}=this.options,{trainOpts:n,model:s,stepCache:o}=this,{learningRate:h}=n,{allMatrices:a}=s;let u=0,l=0;for(let n=0;n<a.length;n++){const s=a[n],{weights:p,deltas:c}=s;n in o||(o[n]=I(s.rows*s.columns));const d=o[n];for(let n=0;n<p.length;n++){let s=c[n];const o=p[n];d[n]=d[n]*i+(1-i)*s*s,s>e?(s=e,u++):s<-e&&(s=-e,u++),l++,p[n]=o+-h*s/Math.sqrt(d[n]+r)-t*o}}this.ratioClipped=u/l}get isRunnable(){return!this.model||0!==this.model.equations.length||(console.error("No equations bound, did you run train()?"),!1)}checkRunnable(){if(!this.isRunnable)throw new Error("Network not runnable")}run(t=[],e=!1,i=1){const r=this.options.maxPredictionLength+(null!==t?t.length:0)+(this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0);this.checkRunnable();const n=this.options.dataFormatter&&t.length>0?this.options.dataFormatter.formatDataIn(t):t,{model:s}=this,o=[];let h=0;for(;;){const t=0===h?0:h<n.length?n[h-1]+1:o[h-1];for(;s.equations.length<=h;)this.bindEquation();const l=s.equations[h].runIndex(t),p=new Gi(s.output.rows,s.output.columns);if(u=l,(a=p).rows=u.rows,a.columns=u.columns,a.weights=u.weights.slice(0),a.deltas=u.deltas.slice(0),1!==i&&e)for(let t=0,e=p.weights.length;t<e;t++)p.weights[t]/=i;const c=dr(p),d=e?mr(c):yr(c);if(h++,0===d)break;if(h>=r)break;o.push(d)}var a,u;return this.options.dataFormatter.formatDataOut(n,o.slice(n.length).map(t=>t-1))}verifyIsInitialized(){this.model.isInitialized||this.initialize()}updateTrainingOptions(t){var e;this.trainOpts={...Lr,...t},this.validateTrainingOptions(this.trainOpts),this.setLogMethod(null!==(e=t.log)&&void 0!==e?e:this.trainOpts.log)}validateTrainingOptions(t){const e={iterations:()=>{const e=t.iterations;return"number"==typeof e&&e>0},errorThresh:()=>{const e=t.errorThresh;return"number"==typeof e&&e>0&&e<1},log:()=>{const e=t.log;return"function"==typeof e||"boolean"==typeof e},logPeriod:()=>{const e=t.logPeriod;return"number"==typeof e&&e>0},learningRate:()=>{const e=t.learningRate;return"number"==typeof e&&e>0&&e<1},callback:()=>{const e=t.callback;return"function"==typeof e||void 0===e},callbackPeriod:()=>{const e=t.callbackPeriod;return"number"==typeof e&&e>0},timeout:()=>{const e=t.timeout;return"number"==typeof e&&e>0}};for(const i in e){const r=t;if(!e[i]())throw new Error(`[${i}, ${r[i]}] is out of normal training range, your network will probably not train.`)}}setLogMethod(t){this.trainOpts.log="function"==typeof t?t:!!t&&console.log}prepTraining(t,e){var i;this.updateTrainingOptions(e);const r=this.options.dataFormatter.format(t),n=Date.now()+(null!==(i=this.trainOpts.timeout)&&void 0!==i?i:0);return this.verifyIsInitialized(),{preparedData:r,status:{error:1,iterations:0},endTime:n}}train(t,e={}){var i;this.trainOpts=e={...Lr,...e};const{iterations:r,errorThresh:n,logPeriod:s,callback:o,callbackPeriod:h}=this.trainOpts,a=!0===e.log?console.log:e.log;let u,l,p=1/0;if(null===(i=this.options)||void 0===i?void 0:i.dataFormatter)l=this.options.dataFormatter.format(t);else{if(!Array.isArray(t)||!Array.isArray(t[0])||"number"!=typeof t[0][0])throw new Error("training not in expected format of number[][]");l=t}for(this.verifyIsInitialized(),u=0;u<r&&p>n;u++){let e=0;for(let t=0;t<l.length;t++){e+=this.trainPattern(l[t],!0)}if(p=e/t.length,isNaN(p))throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");a&&u%s==0&&a(`iterations: ${u}, training error: ${p}`),o&&u%h==0&&o({error:p,iterations:u})}return{error:p,iterations:u}}addFormat(){throw new Error("not yet implemented")}toJSON(){this.model.isInitialized||this.initialize();const{model:t,options:e}=this;return{type:this.constructor.name,options:{...e,dataFormatter:e.dataFormatter.toJSON()},trainOpts:{...this.trainOpts,timeout:this.trainOpts.timeout===1/0?"Infinity":this.trainOpts.timeout},input:t.input.toJSON(),hiddenLayers:t.hiddenLayers.map(t=>{const e={};for(const i in t)t.hasOwnProperty(i)&&(e[i]=t[i].toJSON());return e}),outputConnector:this.model.outputConnector.toJSON(),output:this.model.output.toJSON()}}fromJSON(t){const{options:e}=t,i=[],r=Gi.fromJSON(t.input);i.push(r);const n=[];t.hiddenLayers.forEach(t=>{const e={};for(const r in t)e[r]=Gi.fromJSON(t[r]),i.push(e[r]);n.push(e)});const s=Gi.fromJSON(t.outputConnector);i.push(s);const o=Gi.fromJSON(t.output);return i.push(o),e.dataFormatter?this.options={...br(),...e,dataFormatter:Ui.fromJSON(e.dataFormatter)}:this.options={...br(),...e,dataFormatter:new Ui},this.model=Object.seal({isInitialized:!0,input:r,hiddenLayers:n,output:o,allMatrices:i,outputConnector:s,equations:[],equationConnections:[]}),this.initialLayerInputs=this.options.hiddenLayers.map(t=>new Gi(t,1)),this.bindEquation(),this}toFunction(t){const{model:e}=this,{equations:i}=this.model,r=i[1],{states:n}=r,s=JSON.stringify(this.toJSON());function o(t){const r=e.equationConnections[0],{states:n}=i[0];for(let e=0,i=n.length;e<i;e++)if(n[e].product===t)return e;return r.indexOf(t)}function h(t,i){if(!t||!t.rows||!t.columns)return"null";if(t===e.input)return"json.input";if(t===e.outputConnector)return"json.outputConnector";if(t===e.output)return"json.output";for(let i=0,r=e.hiddenLayers.length;i<r;i++){const r=e.hiddenLayers[i];for(const e in r)if(r.hasOwnProperty(e)&&r[e]===t)return`json.hiddenLayers[${i}].${e}`}return function(t,e){for(let i=0,r=n.length;i<r;i++){const r=n[i];if(i===e){const e=o(t);return e>-1&&(t===r.left||t===r.right)?`typeof prevStates[${e}] === 'object' ? prevStates[${e}].product : new Matrix(${t.rows}, ${t.columns})`:`new Matrix(${t.rows}, ${t.columns})`}if(t===r.product)return`states[${i}].product`;if(t===r.right)return`states[${i}].right`;if(t===r.left)return`states[${i}].left`}return""}(t,i)}function a(t){const e=t.toString().split("{");e.shift();const i=e.join("{").split("}");return i.pop(),i.join("}").split("\n").join("\n        ").replace("product.deltas[i] = 0;","").replace("product.deltas[column] = 0;","").replace("left.deltas[leftIndex] = 0;","").replace("right.deltas[rightIndex] = 0;","").replace("product.deltas = left.deltas.slice(0);","")}function u(t){return`src/recurrent/matrix/${t.replace(/[A-Z]/g,function(t){return`-${t.toLowerCase()}`})}.js`}const l=[],p={},c=[];for(let t=0,e=n.length;t<e;t++){const e=n[t];l.push(`states[${t}] = {\n      name: '${e.forwardFn.name}',\n      left: ${e.left?h(e.left,t):"undefined"},\n      right: ${e.right?h(e.right,t):"undefined"},\n      product: ${h(e.product,t)}\n    }`);const i=e.forwardFn.name;p[i]||(p[i]=!0,c.push(`        case '${i}': //compiled from ${u(i)}\n          ${a(e.forwardFn.toString())}\n          break;`))}const d=`\n  if (typeof rawInput === 'undefined') rawInput = [];\n  if (typeof isSampleI === 'undefined') isSampleI = false;\n  if (typeof temperature === 'undefined') temperature = 1;\n  var json = ${s};\n  ${this.options.dataFormatter?`${this.options.dataFormatter.toFunctionString()};\n  Object.assign(dataFormatter, json.options.dataFormatter);`:""}\n  ${this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataIn?`const formatDataIn = function (input, output) { ${a(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);`:""}\n  ${null!==this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataOut?`const formatDataOut = function formatDataOut(input, output) { ${a(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);`:""}\n  var maxPredictionLength =\n    ${this.options.maxPredictionLength} +\n    rawInput.length +\n    ${this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0};\n  var input = ${this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataIn?"formatDataIn(rawInput)":"rawInput"};\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = (_i === 0\n        ? 0\n        : _i < input.length\n          ? input[_i - 1] + 1\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    prevStates = states;\n    states = [];\n    ${l.join(";\n    ")};\n    for (var stateIndex = 0, stateMax = ${l.length}; stateIndex < stateMax; stateIndex++) {\n      var state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      switch (state.name) {\n${c.join("\n")}\n      }\n    }\n\n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n\n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ${this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataOut?"return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))":"return output.slice(input.length).map(function(value) { return value - 1; })"};\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ${I.toString()}\n  ${dr.toString().replace("_1.Matrix","Matrix")}\n  ${ft.toString()}\n  ${mr.toString()}\n  ${yr.toString()}`;return new Function("rawInput","isSampleI","temperature",t?t(d):d)}trainPattern(t,e){const i=this.trainInput(t);return this.backpropagate(t),this.adjustWeights(),e?i:0}}function kr(t){return t[t.length-1]}class Or extends xr{getHiddenLayer(t,e){return vr(t,e)}getEquation(t,e,i,r){return Ar(t,e,i,r)}}function vr(t,e){return{updateGateInputMatrix:new Vi(t,e,.08),updateGateHiddenMatrix:new Vi(t,t,.08),updateGateBias:new Gi(t,1),resetGateInputMatrix:new Vi(t,e,.08),resetGateHiddenMatrix:new Vi(t,t,.08),resetGateBias:new Gi(t,1),cellWriteInputMatrix:new Vi(t,e,.08),cellWriteHiddenMatrix:new Vi(t,t,.08),cellWriteBias:new Gi(t,1)}}function Ar(t,e,i,r){if(!(r.updateGateInputMatrix&&r.updateGateHiddenMatrix&&r.updateGateBias&&r.resetGateInputMatrix&&r.resetGateHiddenMatrix&&r.resetGateBias&&r.cellWriteInputMatrix&&r.cellWriteHiddenMatrix&&r.cellWriteBias))throw new Error("hiddenLayer does not have expected properties");const n=t.sigmoid.bind(t),s=t.add.bind(t),o=t.multiply.bind(t),h=t.multiplyElement.bind(t),a=t.tanh.bind(t),u=t.allOnes.bind(t),l=t.cloneNegative.bind(t),p=n(s(s(o(r.updateGateInputMatrix,e),o(r.updateGateHiddenMatrix,i)),r.updateGateBias)),c=n(s(s(o(r.resetGateInputMatrix,e),o(r.resetGateHiddenMatrix,i)),r.resetGateBias)),d=a(s(s(o(r.cellWriteInputMatrix,e),o(r.cellWriteHiddenMatrix,h(c,i))),r.cellWriteBias));return s(h(s(u(p.rows,p.columns),l(p)),d),h(i,p))}class Sr{constructor(t,e){this.prop=e,this.length=0,this.table={};for(let i=0;i<t.length;i++){const r=t[i][e];for(let t=0;t<r.length;t++){const e=r[t];for(const t in e)e.hasOwnProperty(t)&&(this.table.hasOwnProperty(t)||(this.table[t]=this.length++))}}}}const Ir=()=>({...br(),inputSize:1,hiddenLayers:[20],outputSize:1,inputRange:0});class zr extends xr{constructor(t={}){super(),this.inputLookupLength=0,this.inputLookup=null,this.outputLookup=null,this.outputLookupLength=0,this.model=Object.seal({isInitialized:!1,hiddenLayers:[],output:new Gi(0,0),equations:[],allMatrices:[],equationConnections:[],outputConnector:new Vi(0,0,.08)}),this.options=Ir(),this.options={...this.options,...t},this.updateTrainingOptions({...Er,...t}),t.json&&this.fromJSON(t.json)}createInputMatrix(){throw new Error("Input Matrices do not exist on RNNTimeStep")}createOutputMatrices(){const{outputSize:t}=this.options,e=kr(this.options.hiddenLayers),i=new Vi(t,e,.08);return{output:new Vi(t,1,.08),outputConnector:i}}bindEquation(){const{model:t,options:e}=this,{hiddenLayers:i,inputSize:r}=e,n=t.hiddenLayers,s=new wr,o=[],h=t.equationConnections.length>0?t.equationConnections[t.equationConnections.length-1]:this.initialLayerInputs;let a=this.getEquation(s,s.input(new Gi(r,1)),h[0],n[0]);o.push(a);for(let t=1,e=i.length;t<e;t++)a=this.getEquation(s,a,h[t],n[t]),o.push(a);t.equationConnections.push(o),s.add(s.multiply(t.outputConnector,a),t.output),t.equations.push(s)}initialize(){this.model=this.mapModel()}mapModel(){const t=[];this.initialLayerInputs=this.options.hiddenLayers.map(t=>new Gi(t,1));const e=this.createHiddenLayers();for(let i=0,r=e.length;i<r;i++){const r=e[i];for(const e in r)r.hasOwnProperty(e)&&t.push(r[e])}const{outputConnector:i,output:r}=this.createOutputMatrices();return t.push(i),t.push(r),Object.seal({isInitialized:!0,hiddenLayers:e,output:r,equations:[],allMatrices:t,equationConnections:[],outputConnector:i})}backpropagate(){for(let t=this.model.equations.length-1;t>-1;t--)this.model.equations[t].backpropagate()}run(t){const e=H.dataShape(t).join(",");switch(e){case"array,number":return this.runArray(t);case"array,array,number":return this.runArrayOfArray(t);case"object,number":return this.runObject(t);case"array,object,number":return this.runArrayOfObject(t);default:throw new Error(`Unrecognized data shape ${e}`)}}forecast(t,e=1){const i=H.dataShape(t).join(",");switch(i){case"array,number":return this.forecastArray(t,e);case"array,array,number":return this.forecastArrayOfArray(t,e);case"object,number":return this.runObject(t);case"array,object,number":return this.forecastArrayOfObject(t,e);default:throw new Error(`Unrecognized data shape ${i}`)}}forecastArray(t,e=1){this.checkRunnable();const{model:i}=this,{equations:r}=i,n=t.length+e;for(;r.length<=n;)this.bindEquation();let s,o=0;if(1===this.options.inputSize)for(let e=0;e<t.length;e++)s=r[o++].runInput(Float32Array.from([t[e]]));else for(let e=0;e<t.length;e++)s=r[o++].runInput(Float32Array.from([]));if(!s)throw new Error("lastOutput not set");const h=[s.weights[0]];for(let t=0,i=e-1;t<i;t++)s=r[o++].runInput(s.weights),h.push(s.weights[0]);return this.end(),Float32Array.from(h)}forecastArrayOfArray(t,e=1){this.checkRunnable();const{model:i}=this,{equations:r}=i,n=t.length+e;for(;r.length<=n;)this.bindEquation();let s,o=0;for(let e=0;e<t.length;e++)s=r[o++].runInput(t[e]);if(!s)throw new Error("lastOutput not set");const h=[Float32Array.from(s.weights)];for(let t=0,i=e-1;t<i;t++)s=r[o++].runInput(s.weights),h.push(Float32Array.from(s.weights.slice(0)));return this.end(),h}forecastArrayOfObject(t,e=1){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");const i=t.map(t=>H.toArray(this.inputLookup,t,this.inputLookupLength));return this.forecastArrayOfArray(i,e).map(t=>H.toObject(this.outputLookup,t))}train(t,e={}){this.trainOpts=e={...Lr,...e},1===this.options.inputSize&&1===this.options.outputSize&&this.setSize(t),this.verifySize();const i=this.formatData(t);let r,n=1/0;this.verifyIsInitialized();const{iterations:s,errorThresh:o,logPeriod:h,callback:a,callbackPeriod:u}=this.trainOpts,l=!0===e.log?console.log:e.log;for(r=0;r<s&&n>o;r++){let t=0;for(let e=0;e<i.length;e++){t+=this.trainPattern(i[e],!0)}if(n=t/i.length,isNaN(n))throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");l&&r%h==0&&l(`iterations: ${r}, training error: ${n}`),a&&r%u==0&&a({error:n,iterations:r})}return{error:n,iterations:r}}trainArrayOfArray(t){if(t.length<2)throw new Error("input must be an array of 2 or more");const{equations:e}=this.model;for(;e.length<t.length;)this.bindEquation();let i=0;for(let r=0,n=t.length-1;r<n;r++)i+=e[r].predictTarget(t[r],t[r+1]);return this.end(),i/t.length}trainPattern(t,e){const i=this.trainArrayOfArray(t);return this.backpropagate(),this.adjustWeights(),e?i:0}setSize(t){let e=0;switch(H.dataShape(t).join(",")){case"array,array,number":case"array,object,number":case"array,datum,array,number":case"array,datum,object,number":e=1;break;case"array,array,array,number":e=t[0][0].length;break;case"array,array,object,number":e=Object.keys(H.toTable2D(t)).length;break;case"array,datum,array,array,number":e=t[0].input[0].length;break;case"array,datum,array,object,number":e=Object.keys(H.toInputTable2D(t)).length;break;default:throw new Error("unknown data shape or configuration")}this.options=Object.seal({...this.options,inputSize:e,outputSize:e})}verifySize(){if((this.options.inputSize||this.options.outputSize)&&this.options.inputSize!==this.options.outputSize)throw new Error("manually set inputSize and outputSize mismatch")}runArray(t){this.checkRunnable();const{equations:e}=this.model;for(;e.length<=t.length;)this.bindEquation();let i;for(let r=0;r<t.length;r++)i=e[r].runInput(new Float32Array([t[r]]));return this.end(),i.weights[0]}runArrayOfArray(t){this.checkRunnable();const{model:e}=this,{equations:i}=e;for(;i.length<=t.length;)this.bindEquation();let r;for(let e=0;e<t.length;e++){r=i[e].runInput(t[e]).weights}return this.end(),null!=r?r:Float32Array.from([])}runObject(t){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");if(!this.outputLookupLength)throw new Error("this.outputLookupLength not set");if(this.inputLookup===this.outputLookup){const e=H.toArrayShort(this.inputLookup,t);return H.toObjectPartial(this.outputLookup,this.forecastArray(e,this.outputLookupLength-e.length),e.length)}return H.toObject(this.outputLookup,this.forecastArray(H.toArray(this.inputLookup,t,this.inputLookupLength),this.outputLookupLength))}runArrayOfObject(t){if(null===this.inputLookup)throw new Error("this.inputLookup not set");if(null===this.outputLookup)throw new Error("this.outputLookup not set");const e=t.map(t=>H.toArray(this.inputLookup,t,this.inputLookupLength));return this.forecastArrayOfArray(e,1).map(t=>H.toObject(this.outputLookup,t))[0]}runArrayOfObjectOfArray(t){if(!this.inputLookup)throw new Error("this.inputLookup not set");if(!this.outputLookup)throw new Error("this.outputLookup not set");return H.toObject(this.outputLookup,this.runArrayOfArray(H.toArrays(this.inputLookup,t,this.inputLookupLength)))}end(){this.model.equations[this.model.equations.length-1].runInput(new Float32Array(this.options.outputSize))}requireInputOutputOfOne(){if(1!==this.options.inputSize)throw new Error("inputSize must be 1 for this data size");if(1!==this.options.outputSize)throw new Error("outputSize must be 1 for this data size")}formatArray(t){const e=[];this.requireInputOutputOfOne();for(let i=0;i<t.length;i++)e.push(Float32Array.from([t[i]]));return[e]}formatArrayOfArray(t){const e=[],{inputSize:i,outputSize:r}=this.options;if(1===i&&1===r){for(let i=0;i<t.length;i++)e.push(xi(t[i]));return e}if(i!==t[0].length)throw new Error("inputSize must match data input size");if(r!==t[0].length)throw new Error("outputSize must match data output size");for(let i=0;i<t.length;i++)e.push(Float32Array.from(t[i]));return[e]}formatArrayOfObject(t){if(this.requireInputOutputOfOne(),!this.inputLookup){const e=new pi(t);this.inputLookup=this.outputLookup=e.table,this.inputLookupLength=this.outputLookupLength=e.length}const e=[];for(let i=0;i<t.length;i++)e.push(Ai(t[i]));return e}formatArrayOfObjectMulti(t){if(!this.inputLookup){const e=new pi(t);this.inputLookup=this.outputLookup=e.table,this.inputLookupLength=this.outputLookupLength=e.length}const e=[];for(let i=0;i<t.length;i++)e.push([Ii(t[i],this.inputLookup,this.inputLookupLength)]);return e}formatArrayOfDatumOfArray(t){const e=[];this.requireInputOutputOfOne();for(let i=0;i<t.length;i++){const r=t[i];e.push(ki(r.input,r.output))}return e}formatArrayOfDatumOfObject(t){if(this.requireInputOutputOfOne(),!this.inputLookup){const e=new pi(t,"input");this.inputLookup=e.table,this.inputLookupLength=e.length}if(!this.outputLookup){const e=new pi(t,"output");this.outputLookup=e.table,this.outputLookupLength=e.length}const e=[];for(let i=0;i<t.length;i++){const r=t[i];e.push(Si(r.input,r.output))}return e}formatArrayOfArrayOfArray(t){const e=[];for(let i=0;i<t.length;i++)e.push(Li(t[i]));return e}formatArrayOfArrayOfObject(t){if(!this.inputLookup){const e=new pi(t);this.inputLookup=this.outputLookup=e.table,this.inputLookupLength=this.outputLookupLength=e.length}const e=[];for(let i=0;i<t.length;i++){const r=[];for(let e=0;e<t[i].length;e++)r.push(Ii(t[i][e],this.inputLookup,this.inputLookupLength));e.push(r)}return e}formatArrayOfDatumOfArrayOfArray(t){const e=[],{inputSize:i,outputSize:r}=this.options;if(i!==t[0].input[0].length)throw new Error("inputSize must match data input size");if(r!==t[0].output[0].length)throw new Error("outputSize must match data output size");for(let i=0;i<t.length;i++){const r=t[i];e.push(bi(r.input,r.output))}return e}formatArrayOfDatumOfArrayOfObject(t){if(!this.inputLookup){const e=new Sr(t,"input");this.inputLookup=e.table,this.inputLookupLength=e.length}if(!this.outputLookup){const e=new Sr(t,"output");this.outputLookup=e.table,this.outputLookupLength=e.length}if(!this.outputLookupLength)throw new Error("this.outputLookupLength not set to usable number");const e=[];for(let i=0;i<t.length;i++){const r=t[i];e.push(vi(r.input,r.output,this.inputLookup,this.outputLookup,this.inputLookupLength,this.outputLookupLength))}return e}formatData(t){switch(H.dataShape(t).join(",")){case"array,number":return this.formatArray(t);case"array,array,number":return this.formatArrayOfArray(t);case"array,object,number":return 1===this.options.inputSize?this.formatArrayOfObject(t):this.formatArrayOfObjectMulti(t);case"array,datum,array,number":return this.formatArrayOfDatumOfArray(t);case"array,datum,object,number":return this.formatArrayOfDatumOfObject(t);case"array,array,array,number":return this.formatArrayOfArrayOfArray(t);case"array,array,object,number":return this.formatArrayOfArrayOfObject(t);case"array,datum,array,array,number":return this.formatArrayOfDatumOfArrayOfArray(t);case"array,datum,array,object,number":return this.formatArrayOfDatumOfArrayOfObject(t);default:throw new Error("unknown data shape or configuration")}}test(t){const e=[];let i=0;const r=this.formatData(t);for(let n=0;n<r.length;n++){const s=r[n],o=this.run(s.splice(0,s.length-1)),h=s[s.length-1];let a=0,u=0;for(let t=0;t<o.length;t++){u++;const e=h[t]-o[t];a+=e*e}if(i+=a/u,Math.abs(a)>this.trainOpts.errorThresh){const i=t[n];e.push({value:i,actual:o})}}return{error:i/r.length,misclasses:e,total:r.length}}addFormat(t){var e,i,r,n,s,o;switch(H.dataShape(t).join(",")){case"array,array,number":case"datum,array,array,number":case"array,number":case"datum,array,number":return;case"datum,object,number":this.inputLookup=H.addKeys(t.input,null!==(e=this.inputLookup)&&void 0!==e?e:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length),this.outputLookup=H.addKeys(t.output,null!==(i=this.outputLookup)&&void 0!==i?i:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length);break;case"object,number":this.inputLookup=this.outputLookup=H.addKeys(t,null!==(r=this.inputLookup)&&void 0!==r?r:{}),this.inputLookup&&(this.inputLookupLength=this.outputLookupLength=Object.keys(this.inputLookup).length);break;case"array,object,number":{const e=t;for(let t=0;t<e.length;t++)this.inputLookup=this.outputLookup=H.addKeys(e[t],null!==(n=this.inputLookup)&&void 0!==n?n:{}),this.inputLookup&&(this.inputLookupLength=this.outputLookupLength=Object.keys(this.inputLookup).length);break}case"datum,array,object,number":{const e=t,i=e.input;for(let t=0;t<i.length;t++)this.inputLookup=H.addKeys(i[t],null!==(s=this.inputLookup)&&void 0!==s?s:{}),this.inputLookup&&(this.inputLookupLength=Object.keys(this.inputLookup).length);const r=e.output;for(let t=0;t<r.length;t++)this.outputLookup=H.addKeys(r[t],null!==(o=this.outputLookup)&&void 0!==o?o:{}),this.outputLookup&&(this.outputLookupLength=Object.keys(this.outputLookup).length);break}default:throw new Error("unknown data shape or configuration")}}toJSON(){this.model||this.initialize();const{model:t}=this,e={...this.options,...br};return{type:this.constructor.name,options:e,hiddenLayers:t.hiddenLayers.map(t=>{const e={};for(const i in t)t.hasOwnProperty(i)&&(e[i]=t[i].toJSON());return e}),outputConnector:t.outputConnector.toJSON(),output:t.output.toJSON(),inputLookup:this.inputLookup,inputLookupLength:this.inputLookupLength,outputLookup:this.outputLookup,outputLookupLength:this.outputLookupLength}}fromJSON(t){const{options:e}=t,i=[],r=[];t.hiddenLayers.forEach(t=>{const e={};for(const r in t)e[r]=Gi.fromJSON(t[r]),i.push(e[r]);r.push(e)});const n=Gi.fromJSON(t.outputConnector);i.push(n);const s=Gi.fromJSON(t.output);return i.push(s),this.options={...Ir(),...e},this.inputLookup=t.inputLookup,this.inputLookupLength=t.inputLookupLength,this.outputLookup=t.outputLookup,this.outputLookupLength=t.outputLookupLength,this.model=Object.seal({isInitialized:!0,hiddenLayers:r,output:s,allMatrices:i,outputConnector:n,equations:[],equationConnections:[]}),this.initialLayerInputs=e.hiddenLayers.map(t=>new Gi(t,1)),this.bindEquation(),this}toFunction(t){const{model:e,inputLookup:i,inputLookupLength:r,outputLookup:n,outputLookupLength:s}=this,{inputSize:o}=this.options,{equations:h}=e,a=h[1],{states:u}=a,l=JSON.stringify(this.toJSON());function p(t){const i=e.equationConnections[0],{states:r}=h[0];for(let e=0,i=r.length;e<i;e++)if(r[e].product===t)return e;return i.indexOf(t)}function c(t,i){if(!t||!t.rows||!t.columns)return"null";if(t===e.outputConnector)return"json.outputConnector";if(t===e.output)return"json.output";for(let i=0,r=e.hiddenLayers.length;i<r;i++){const r=e.hiddenLayers[i];for(const e in r)if(r.hasOwnProperty(e)&&r[e]===t)return`json.hiddenLayers[${i}].${e}`}return function(t,e){for(let i=0,r=u.length;i<r;i++){const r=u[i];if(i===e){const e=p(t);switch(t){case r.left:if(e>-1)return`typeof prevStates[${e}] === 'object' ? prevStates[${e}].product : new Matrix(${t.rows}, ${t.columns})`;case r.right:if(e>-1)return`typeof prevStates[${e}] === 'object' ? prevStates[${e}].product : new Matrix(${t.rows}, ${t.columns})`;case r.product:return`new Matrix(${t.rows}, ${t.columns})`;default:throw Error("unknown state")}}if(t===r.product)return`states[${i}].product`;if(t===r.right)return`states[${i}].right`;if(t===r.left)return`states[${i}].left`}return""}(t,i)}function d(t){const e=t.toString().split("{");e.shift();const i=e.join("{").split("}");return i.pop(),i.join("}").split("\n").join("\n        ").replace("product.deltas[i] = 0;","").replace("product.deltas[column] = 0;","").replace("left.deltas[leftIndex] = 0;","").replace("right.deltas[rightIndex] = 0;","").replace("product.deltas = left.deltas.slice(0);","")}function g(t){return`src/recurrent/matrix/${t.replace(/[A-Z]/g,function(t){return`-${t.toLowerCase()}`})}.js`}const f=[],w={},y=[];for(let t=0,e=u.length;t<e;t++){const e=u[t];f.push(`states[${t}] = {\n      name: '${e.forwardFn.name}',\n      left: ${e.left?c(e.left,t):"undefined"},\n      right: ${e.right?c(e.right,t):"undefined"},\n      product: ${c(e.product,t)}\n    }`);const r=e.forwardFn.name;w[r]||(w[r]=!0,"input"===e.name?(y.push(`case '${r}':`),y.push(i&&1===o?"product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;":1===o?"product.weights = [input[_i]];":"product.weights = input[_i];"),y.push("break;")):y.push(`        case '${r}':${"forwardFn"!==r?` //compiled from ${g(r)}`:""}\n          ${d(e.forwardFn.toString())}\n          break;`))}const m=1===o&&this.outputLookup,L=`\n  var input = ${this.inputLookup?"lookupInput(rawInput)":"rawInput"};\n  var json = ${l};\n  var output = [];\n  var states = [];\n  var prevStates;\n  var state;\n  var max = ${m?i===n?r:`input.length + ${s-1}`:"input.length"};\n  for (var _i = 0; _i < max; _i++) {\n    prevStates = states;\n    states = [];\n    ${f.join(";\n    ")};\n    for (var stateIndex = 0, stateMax = ${f.length}; stateIndex < stateMax; stateIndex++) {\n      state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n\n      switch (state.name) {\n${y.join("\n")}\n      }\n    }\n    ${1===o&&i?"if (_i >= input.length - 1) { output.push(state.product.weights); }":"output = state.product.weights;"}\n  }\n  ${n?n===i?"return lookupOutputPartial(output, input)":"return lookupOutput(output)":1===o?"return output[0]":"return output"};\n  ${i?1===o?i===n?`function lookupInput(input) {\n            var table = ${JSON.stringify(i)};\n            var result = [];\n            for (var p in table) {\n              if (!input.hasOwnProperty(p)) break;\n              result.push(Float32Array.from([input[p]]));\n            }\n            return result;\n          }`:`function lookupInput(input) {\n          var table = ${JSON.stringify(i)};\n          var result = [];\n          for (var p in table) {\n            result.push(Float32Array.from([input[p]]));\n          }\n          return result;\n        }`:`function lookupInput(rawInputs) {\n        var table = ${JSON.stringify(i)};\n        var result = [];\n        for (var i = 0; i < rawInputs.length; i++) {\n          var rawInput = rawInputs[i];\n          var input = new Float32Array(${r});\n          for (var p in table) {\n            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;\n          }\n          result.push(input);\n        }\n        return result;\n      }`:""}\n  ${n?1===o?i===n?`function lookupOutputPartial(output, input) {\n            var table = ${JSON.stringify(n)};\n            var offset = input.length;\n            var result = {};\n            var i = 0;\n            for (var p in table) {\n              if (i++ < offset) continue;\n              result[p] = output[table[p] - offset][0];\n            }\n            return result;\n          }`:`function lookupOutput(output) {\n          var table = ${JSON.stringify(n)};\n          var result = {};\n          for (var p in table) {\n            result[p] = output[table[p]][0];\n          }\n          return result;\n        }`:`function lookupOutput(output) {\n        var table = ${JSON.stringify(n)};\n        var result = {};\n        for (var p in table) {\n          result[p] = output[table[p]];\n        }\n        return result;\n      }`:""}\n\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ${I.toString()}\n  ${dr.toString().replace("_2.default","Matrix")}\n  ${ft.toString()}\n  ${mr.toString()}\n  ${yr.toString()}`;return new Function("rawInput",t?t(L):L)}}const Er={...Lr};class $r extends zr{getHiddenLayer(t,e){return vr(t,e)}getEquation(t,e,i,r){return Ar(t,e,i,r)}}class Mr extends xr{getHiddenLayer(t,e){return Pr(t,e)}getEquation(t,e,i,r){return _r(t,e,i,r)}}function Pr(t,e){return{inputMatrix:new Vi(t,e,.08),inputHidden:new Vi(t,t,.08),inputBias:new Gi(t,1),forgetMatrix:new Vi(t,e,.08),forgetHidden:new Vi(t,t,.08),forgetBias:new Gi(t,1),outputMatrix:new Vi(t,e,.08),outputHidden:new Vi(t,t,.08),outputBias:new Gi(t,1),cellActivationMatrix:new Vi(t,e,.08),cellActivationHidden:new Vi(t,t,.08),cellActivationBias:new Gi(t,1)}}function _r(t,e,i,r){if(!(r.inputMatrix&&r.inputHidden&&r.inputBias&&r.forgetMatrix&&r.forgetHidden&&r.forgetBias&&r.outputMatrix&&r.outputHidden&&r.outputBias&&r.cellActivationMatrix&&r.cellActivationHidden&&r.cellActivationBias))throw new Error("hiddenLayer does not have expected properties");const n=t.sigmoid.bind(t),s=t.add.bind(t),o=t.multiply.bind(t),h=t.multiplyElement.bind(t),a=t.tanh.bind(t),u=n(s(s(o(r.inputMatrix,e),o(r.inputHidden,i)),r.inputBias)),l=n(s(s(o(r.forgetMatrix,e),o(r.forgetHidden,i)),r.forgetBias)),p=n(s(s(o(r.outputMatrix,e),o(r.outputHidden,i)),r.outputBias)),c=a(s(s(o(r.cellActivationMatrix,e),o(r.cellActivationHidden,i)),r.cellActivationBias)),d=h(l,i),g=h(u,c);return h(p,a(s(d,g)))}class Kr extends zr{getHiddenLayer(t,e){return Pr(t,e)}getEquation(t,e,i,r){return _r(t,e,i,r)}}function Tr({pixelX:t,pixelY:e,radius:i,inputs:r,row:n,line:s,fontSize:o,fontClassName:h}){let a=`<rect\n              x="${t/2-i}"\n              y="${e/2+n*e-i}"\n              width="${2*i}"\n              height="${2*i}"\n              stroke="black"\n              stroke-width="1"\n              fill="${r.color}"\n              class="${r.className}" />\n            <line\n              x1="${t/4}"\n              y1="${e/2+n*e}"\n              x2="${t/2-i}"\n              y2="${e/2+n*e}"\n              style="stroke:${s.color};stroke-width:${s.width}"\n              class="${s.className}" />`;return r.labels&&(a+=`<text\n              x="${t/8}"\n              y="${e/2+n*e-5}"\n              fill="black"\n              font-size="${o}"\n              class="${h}">${r.labels[n]}</text>`),a}function Dr({pixelX:t,pixelY:e,row:i,column:r,radius:n,hidden:s}){return`<circle\n            cx="${t/2+r*t}"\n            cy="${e/2+i*e}"\n            r="${n}"\n            stroke="black"\n            stroke-width="1"\n            fill="${s.color}"\n            class="${s.className}" />`}function jr({pixelX:t,pixelY:e,row:i,column:r,line:n,outputs:s,radius:o}){return`<circle\n            cx="${t/2+r*t}"\n            cy="${e/2+i*e}"\n            r="${o}"\n            stroke="black"\n            stroke-width="1"\n            fill="${s.color}"\n            class="${s.className}" />\n          <line\n            x1="${t/2+r*t+o}"\n            y1="${e/2+i*e}"\n            x2="${t/2+r*t+t/4}"\n            y2="${e/2+i*e}"\n            style="stroke:${n.color};stroke-width:${n.width}"\n            class="${n.className}" />`}function Fr({pixelX:t,pixelY:e,row:i,column:r,radius:n,lineY:s,line:o,previousConnectionIndex:h}){return`<line\n            x1="${t/2+(r-1)*t+n}"\n            y1="${s/2+h*s}"\n            x2="${t/2+r*t-n}"\n            y2="${e/2+i*e}"\n            style="stroke:${o.color};stroke-width:${o.width}"\n            class="${o.className}" />`}function Nr(t){const{sizes:e,height:i,width:r}=t;let n="";const s=r/e.length;for(let r=0;r<e.length;r++){const o=e[r],h=i/o;for(let a=0;a<o;a++)if(0===r)n+=Tr({pixelX:s,pixelY:h,row:a,column:r,...t});else{r===e.length-1?n+=jr({pixelX:s,pixelY:h,row:a,column:r,...t}):n+=Dr({pixelX:s,pixelY:h,row:a,column:r,...t});const o=e[r-1],u=i/o;for(let e=0;e<o;e++)n+=Fr({pixelX:s,pixelY:h,row:a,column:r,lineY:u,previousConnectionIndex:e,...t})}}return n}function Cr({pixelX:t,pixelY:e,row:i,column:r,radius:n,recurrentLine:s}){const o=t/2+r*t+n+1,h=e/2+i*e,a=o-2*n-2;return`<path\n              d="M ${o} ${h} C ${a+100} ${h+50}, ${o-100} ${h+50}, ${a} ${h}"\n              stroke="${s.color}"\n              stroke-width="${s.width}"\n              fill="transparent"\n              stroke-linecap="round"\n              marker-end="url(#arrow)"\n              class="${s.className}" />`}function Rr(t){const{width:e,height:i,recurrentLine:r,sizes:n,radius:s}=t,o=e/n.length;let h=`<defs>\n              <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">\n                <path d="M0,0 L0,6 L9,3 z" fill="${r.color}" />\n              </marker>\n            </defs>`;h+=Nr(t);for(let t=1;t<n.length;t++){const e=n[t],a=i/e;for(let i=0;i<e;i++)h+=Cr({pixelX:o,pixelY:a,row:i,column:t,radius:s,recurrentLine:r})}return h}function Hr(t,e,i){return`<svg\n            xmlns="http://www.w3.org/2000/svg"\n            xmlns:xlink="http://www.w3.org/1999/xlink"\n            version="1.1"\n            width="${e}"\n            height="${i}">${t}</svg>`}function qr(t){const{options:e}=t,{inputSize:i,outputSize:r,hiddenLayers:n}=e;return[i].concat(n).concat([r])}function Wr(t,e){if(!t)throw new Error("sizes not set");if(t.some(t=>t<1))throw new Error("sizes not set correctly");if(e&&e.length!==t[0])throw new Error("not enough labels for inputs");return t}const Xr={RNNTimeStep:zr,LSTMTimeStep:Kr,GRUTimeStep:$r,RNN:xr,LSTM:Mr,GRU:Or},Yr={max:zi,mse:Ei,ones:pe,ones2D:ce,random:yt,randomWeight:gt,randos:mt,range:function(t,e){const i=[];for(;t<e;t++)i.push(t);return i},toArray:function(t){return Array.isArray(t)?Float32Array.from(t):Float32Array.from(Object.values(t))},DataFormatter:Ui,zeros:I,toSVG:function(t,e){const i={line:{width:.5,color:"black",className:"connection"},recurrentLine:{width:1,color:"red",className:"recurrence"},inputs:{color:"rgba(0, 128, 0, 0.5)",labels:null,className:"input"},outputs:{color:"rgba(100, 149, 237, 0.5)",className:"output"},hidden:{color:"rgba(255, 127, 80, 0.5)",className:"hidden-neuron"},fontSize:"14px",fontClassName:"label",radius:8,width:400,height:250,sizes:[],...e},{width:r,height:n,inputs:s}=i;let o=[];if(t instanceof Mi||t instanceof Yi)o=function(t){const{options:e,sizes:i}=t,{inputSize:r,outputSize:n,hiddenLayers:s}=e;if(!i){if("number"==typeof r&&r<1)throw new Error("inputSize not set");if("number"==typeof n&&n<1)throw new Error("outputSize not set");if(null==s?void 0:s.some(t=>t<1))throw new Error("hiddenLayers not set")}return"number"==typeof r&&Array.isArray(s)&&"number"==typeof n?[r].concat(s).concat([n]):i}(t);else if(t instanceof Bi){const{inputSize:e,hiddenLayers:i,outputSize:r}=function(t){const e=[],{options:i}=t;if(!i.inputLayer)throw new Error("inputLayer not defined");if(!i.outputLayer)throw new Error("outputLayer not defined");const r=i.inputLayer();e.push(i.hiddenLayers[0](r,Fe(),0));for(let t=1;t<i.hiddenLayers.length;t++)e.push(i.hiddenLayers[t](e[t-1],Fe(),t));const n=i.outputLayer(e[e.length-1],-1);return{inputSize:r.height,hiddenLayers:e.map(t=>t.height),outputSize:n.height}}(t);o=[e].concat(i).concat([r])}else if(t instanceof gi){const{inputSize:e,hiddenLayers:i,outputSize:r}=function(t){const{options:e}=t;if(!e)throw new Error("options not defined");if(!e.inputLayer)throw new Error("options.inputLater not defined");if(!e.hiddenLayers)throw new Error("options.hiddenLayers not defined");if(e.hiddenLayers.length<1)throw new Error("options.hiddenLayers is empty");if(!e.outputLayer)throw new Error("options.outputLayer not defined");const i=e.inputLayer(),r=[];r.push(e.hiddenLayers[0](i,0));for(let t=1;t<e.hiddenLayers.length;t++)r.push(e.hiddenLayers[t](r[t-1],t));const n=e.outputLayer(r[r.length-1],r.length);return{inputSize:i.height,hiddenLayers:r.map(t=>t.height),outputSize:n.height}}(t);o=[e].concat(i).concat([r])}else{if(t instanceof xr||t instanceof Mr||t instanceof Or||t instanceof zr||t instanceof Kr||t instanceof $r)return Hr(Rr({...i,sizes:Wr(qr(t),s.labels)}),r,n);if(t.hasOwnProperty("type"))switch(t.type){case"NeuralNetwork":case"NeuralNetworkGPU":return Hr(Nr({...i,sizes:Wr((h=t,h.sizes),s.labels)}),r,n);case"RNN":case"GRU":case"LSTM":case"RNNTimeStep":case"GRUTimeStep":case"LSTMTimeStep":return Hr(Rr({...i,sizes:Wr(qr(t),s.labels)}),r,n);default:throw new Error("unrecognized network")}else if(t.hasOwnProperty("inputSize")&&t.hasOwnProperty("hiddenLayers")&&t.hasOwnProperty("outputSize")){const{inputSize:e,hiddenLayers:i,outputSize:r}=t;o=[e,...i,r]}else{if(!t.hasOwnProperty("sizes"))throw new Error("unrecognized network");o=t.sizes}}var h;return Hr(Nr({...i,sizes:Wr(o,s.labels)}),r,n)}};t.CrossValidate=f,t.FeedForward=gi,t.NeuralNetwork=Mi,t.NeuralNetworkGPU=Yi,t.Recurrent=Bi,t.activation=g,t.layer=ai,t.layerTypes=hi,t.likely=function(t,e){if(!e)throw new TypeError(`Required parameter 'net' is of type ${typeof e}. Must be of type 'brain.NeuralNetwork'`);const i=e.run(t);let r=null,n=-1;return Object.entries(i).forEach(([t,e])=>{void 0!==e&&"number"==typeof e&&e>n&&(r=t,n=e)}),r},t.lookup=H,t.praxis=ht,t.recurrent=Xr,t.utilities=Yr,Object.defineProperty(t,"__esModule",{value:!0})});